var documenterSearchIndex = {"docs":
[{"location":"quick-start/#快速入门-1","page":"快速入门","title":"快速入门","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"尽管本书不会过多关注基础入门知识，但是为了让我们的读者能够站在同一起跑线上，我们在这一节快速过一遍 Julia 的各种语法。如果你已经对 Julia 很熟练了，那么不要浪费时间请跳过本节。如果你对 Julia 还不了解，我依然建议你完整阅读 Julia 官方文档的手册部分（Manual），这部分我删去了很多细节，而着重在相对深入的概念解释和针对一些有学习过其它语言的人的常见误区的解释。如果你只是刚刚上手，我依然非常推荐你阅读这一部分，它会帮助你避免很多坑。","category":"page"},{"location":"quick-start/#变量（Variable）-1","page":"快速入门","title":"变量（Variable）","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"Julia 语言中最基础的元素是变量，简单的来说变量就是一个绑定了一个值（value）的名字（name），例如","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"x = 1","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"这里 x 是一个变量，它的名字叫 x，它的值是一个数字 1。但是一个名字并不需要唯一的绑定这个值，","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"x = \"我是一个变量的值\"","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"note: Note\n在 C/C++ 里，一个变量是唯一绑定一个类型的，并且对应内存地址。Julia 的变量类似于 C++ 的引用（reference）， 但依然在语义上不完全一样。具体的一个体现就是 Julia 不能重载赋值运算符，因为由于变量只是绑定一个名字，所以不存在 需要重载赋值运算的场景。单独使用 = 永远只表示给右边的值绑定左边的名字。","category":"page"},{"location":"quick-start/#类型（Type）-1","page":"快速入门","title":"类型（Type）","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"类型是一种标记，它存在的目的是为了告诉编译器部分关于你代码的信息，或者简单来说，它是对变量的“分类”。Julia 语言是一个强类型（strong typed）语言，这意味着所有的变量/值都有一个类型。比如 1 的类型是 Int，你可以用 typeof(1)来查看它。","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"当我们把一个值绑定给一个变量之后，这个变量也自动具有了对应的类型","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"x = 1\ntypeof(x)","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"如果你给这个变量赋予了新的值，那么变量的类型也会改变","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"x = \"我是一个变量的值\"\ntypeof(x)","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"而类型的类型是数据类型 DataType","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"typeof(Int)","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"DataType 的类型还是 DataType","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"typeof(DataType)","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"在 Julia 里所有的变量都有一个类型，你可以用 typeof 来获取它。","category":"page"},{"location":"quick-start/#函数-1","page":"快速入门","title":"函数","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"Julia 是一个构建在多重派发（multiple dispatch）基础上的语言，它的函数实际上是一般的，有些翻译里也称为范型的函数（generic function）。而我们每一个具体的函数定义都会为这个函数增加一种方法（method），方法是一种具体执行这个范型函数的方式。所以很自然的，我们可以声明没有任何方法的函数","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"function foo\nend","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"而每一种不同的输入类型的组合都将创建一个新的方法，","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"function foo(x)\n   x + 1\n   return x\nend","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"这里 function 和 end 关键字作为标识函数声明的符号。有人也许会有疑问，为什么 Julia 里要使用 end 作为结尾，而不是 {} 或者像 Python 一样使用缩进呢？当你阅读到表达式这一部分我想你就能够得到部分答案，当你掌握元编程之后，你便会体会到 end 的妙处。","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"或者，你也可以使用更简洁的写法。但是注意由于这个声明和上一个声明的类型标签相同（都是一个 Any 类型的函数参数）","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"foo(x) = x + 1","category":"page"},{"location":"quick-start/#类型标注-1","page":"快速入门","title":"类型标注","text":"","category":"section"},{"location":"quick-start/#带类型标注的方法声明-1","page":"快速入门","title":"带类型标注的方法声明","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"我们还可以对函数参数加上类型标注（type annotation），这将具体规定这个方法所适配的类型，例如","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"foo(x::Int) = 2x","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"或者是更多的变量，不同类型的组合等等","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"foo(x::Int, y::Float32) = y\nfoo(x::Float32, y::Int) = x + y\nfoo(x, y) = 2x + y","category":"page"},{"location":"quick-start/#控制流-1","page":"快速入门","title":"控制流","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"一般来说，控制流包含两种。一种是循环表达式，一种是条件表达式。","category":"page"},{"location":"quick-start/#循环表达式-1","page":"快速入门","title":"循环表达式","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"Julia 中可以使用常见的两种方式定义循环，一种是 for 一种是 while。for 关键字后跟 in 关键字表示需要循环的区间","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"function foo(start)\n    for k in start:10\n        @show k\n    end\nend\n\nfoo(2)","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"另外一种则是 while ","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"function foo(start)\n    k = start\n    while k < 10\n        @show k\n        k += 1\n    end\nend\n\nfoo(2)","category":"page"},{"location":"quick-start/#条件表达式-1","page":"快速入门","title":"条件表达式","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"条件表达式即 if ... else ... end，例如","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"function foo(x)\n    if x > 0\n        println(\"x 比 0 大\")\n    elseif x > -1\n        println(\"x > -1\")\n    else\n        print(\"x <= -1\")\n    end\nend\n\nfoo(1)\nfoo(-0.5)\nfoo(-1)","category":"page"},{"location":"quick-start/#自定义类型-1","page":"快速入门","title":"自定义类型","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"一般来说我们会使用两种组合类型（composite type），这些类型由其它的数据类型组合而来。而在 Julia 里有两种，一种是成员的值在定义之后可变的类型，另外一种是成员的值在定义之后不可变的类型。类型在 Julia 中主要有两个作用：一是用来派发方法（method），二是用来包装数据结构。","category":"page"},{"location":"quick-start/#不可变类型-1","page":"快速入门","title":"不可变类型","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"不可变类型使用 struct 关键字进行声明（也就是说我们默认一个类型是不可变的），格式如下","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"struct Cat\n    name::String\nend","category":"page"},{"location":"quick-start/#可变类型-1","page":"快速入门","title":"可变类型","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"可变类型需要使用 mutable 关键字进行标注","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"mutable struct Cat\n    name::String\nend","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"note: Note\n在Julia里，从语义上讲（semantically）我们不区分这两种类型对应的内存分配方式。但是在优化层面，尽管 Julia 没有提供 像 C++ 一样的显式声明栈上分配的内存（stack allocated）的语义，但是通过对不可变等性质的推导，它依然可以和 C++ 达到相近 的内存分配大小 [相关讨论]。","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"[相关讨论]: 相关讨论可以参见discourse上的帖子:Why mutable structs are allocated on the heap?\nClarification about memory management of immutable and mutable struct","category":"page"},{"location":"quick-start/#参数类型-1","page":"快速入门","title":"参数类型","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"在很多情况下，一些类型有着相近的含义和数据结构，但是它们需要派发的方法可能有所不同。这个时候我们往往会需要用到参数类型。Julia 中类型参数可以使用大括号 {} 声明。类型参数本身在编译时期也是有类型的，统一为 TypeVar 类型。例如下面这个文档中也用到了的复数类型的例子。对于类型参数，我们可以使用 <: 来声明它的上界。","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"struct Complex{T <: Number}\n    real::T\n    imag::T\nend","category":"page"},{"location":"quick-start/#数组-1","page":"快速入门","title":"数组","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"数组是一种特别的类型，和其它语言不同的是，在 Julia 我们的数组是多维数组（multi-dimensional array）。所谓数组，实际上它是一种对内存的抽象模型。在 Julia 里一个数组类型（Array）的实例代表了一块连续的内存","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"在 Julia 里它扮演了两种角色：计算机意义上的数组以及数学意义上的多维张量。在很多机器学习框架中，也往往实现了多维数组或者张量（Tensor，例如 PyTorch）。而这些实现本质上只是一种对一块连续内存的查看方式。","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"一般来说多维数组的实际数据结构如下","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"struct MyArray{T, N}\n    storage::Ptr{T}\n    size::NTuple{N, Int}\n    strides::NTuple{N, Int}\nend","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"其中 storage 是一个指向某块内存的指针，这块内存上存了一些 T 类型构成的元素 ，size 记录了这个多维数组的大小，strides 则用来表示每个维度之间间隔的元素个数，什么意思呢？例如下表是一个有 20 个浮点类型（双精度）的内存块，它可能存储了一个 4x5 矩阵的值，也有可能存储了一个 2x5x2 的三阶张量的值。","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"内存地址 0xf21010 0xf21018 0xf21020 cdots 0xf210a0 0xf210a8\n值 0.0 1.0 2.0 cdots 18.0 19.0","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"向系统申请这个内存块，在不再使用之后删除所分配的内存并不需要知道对应张量的大小。甚至有可能几个元素数目不同但是总数相同的张量（比如 4x4, 2x2x2x2, 1x16 的不同大小张量）可以通过用不同的 MyArray 共享一块内存。但当我们需要完成张量的一些运算，例如对于矩阵，他们的乘积（matrix product），点积（dot product）等运算会需要使用维度的信息（各个维度的大小）并且这个时候我们将按照维度来访问不同位置的元素，这使得我们首先需要存储各个维度的大小 size ，但是这还不够，我们实际上在访问一块连续内存的时候实际上使用的是不同维度上的间隔，例如第一个维度上的间隔一般是 0，第二个维度上的间隔是第一个维度的大小size[0]，依次类推，但也有可能由于是由某个较大的张量分割来的，并不满足上述间隔分配方式，所以我们有必要再用一个数组存储各个维度的间隔大小 strides。这样在访问某个角标 ijk 对应的内存地址时就可以用","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"(i - 1) * strides[0] + (j - 1) * strides[1] + (k - 1) * strides[2]","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"作为一个元素的真实内存地址了。当然 Julia 已经为我们做好了这些事情，在平时使用的时候我们不需要去在意它到底是怎么实现的。但是在我们后面的章节里，我们还会用到这些性质和定义。","category":"page"},{"location":"quick-start/#数组的-view-1","page":"快速入门","title":"数组的 view","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"我们上面讲了多维数组其实是一种对一块内存的查看方式，而在对数组进行分块的时候 Julia 和 MATLAB 以及 Python 的 numpy 有一个很大的不同是在 Julia 里对诸如A[1, :]之类的分块操作都是创建一个新的内存，然后将这部分内容拷贝到新的内存空间上去，从而保证对 A[1, :] 的原地（in-place）操作不会影响到 A ，这能够保证你的程序是正确并且安全的。但是在很多情况下，我们是不需要拷贝的，这会让你的代码变慢，很多从 MATLAB 或者 Python 转到 Julia 的用户都会犯这个错误，而如果我们只是要查看这部分元素，则要借助 view ，它会产生一个 SubArray类型的实例，不会进行拷贝。如果你希望将某一整块代码中的分块操作都变成这样的行为，你可以用 @views 这个宏将这部分代码包裹起来。我们曾经在中文论坛上遇到过一个很典型例子 [参见discourse]。","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"[参见discourse]: 你可以通过这个例子了解到这一技巧是如何被具体的使用的：Julia内存分配随着循环的进行越来越大。","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"note: Note\n目前 view 暂时创建的 SubArray 依然会在堆（heap）上分配一个很小的内存。这会造成一定的额外开销，这是一个已知的问题[issue14995]，在这个问题被彻底从编译器层面解决前，你可以使用 UnsafeArrays.jl 来暂时解决这个问题。","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"[issue14995]: 参见 JuliaLang/julia#14955","category":"page"},{"location":"quick-start/#数组的接口（interface）-1","page":"快速入门","title":"数组的接口（interface）","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"Julia 在标准库里提供了大量的一般性的方法，这意味着通过重载少量必要的接口，你就可以使用大部分的功能。数组也不例外，这也是为什么 Julia 里多维数组的生态如此丰富的原因之一。我们往往可以通过为特定结构的，使用特定硬件的数组定义单独的类型的和部分特化的方法（method），而剩余的部分则会通过这些一般性的方法自动被编译器推导出来。","category":"page"},{"location":"quick-start/#表达式-1","page":"快速入门","title":"表达式","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"在 Julia 里，任何一段程序都首先是一段表达式（expression）。所谓的表达式是一种数据结构，它存储了一段程序的抽象语法树（abstract syntax tree）。我们可以用引用（quote）语法来获取一段程序的表达式","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"ex = :(1 + 2 * b)\ntypeof(ex)","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"而 ex 的类型则是 Expr 类型。而表达式中暂时没有值的变量则会被解析为一个符号，它的类型是 Symbol，你可以通过 : + 一段合法的变量名 获得这样一个符号。它相当于一种特别的字符串。","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"typeof(:a)","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"Expr 类型里的结构很简单，它包括一个符号类型的头，作为这段表达式的标签，以及一个一维的 Any 类型数组，这个数组将存储这个表达式的子表达式。这里 dump 将会打印出一个 Julia 对象的内部结构。","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"dump(Expr)","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"我们不妨看看上面的表达式是什么样子的","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"dump(:(1 + 2 * b))","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"这是什么意思呢？首先，抽象语法树会把这样一段表达式存储成如下的形式","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"using GraphRecipes # hide\nusing Plots # hide\ndefault(size=(300, 300)) # hide\npyplot() # hide\ncode = :(1 + 2 * b) # hide\nplot(code, fontsize=12, shorten=0.01, axis_buffer=0.15, nodeshape=:rect) # hide","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"而上面的 Expr 就存储了这样一颗树，它的根结点是最低优先级的 + 函数的函数调用，","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"ex.head\nex.args[1]","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"这个函数调用有两个输入，分别是","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"ex.args[2]\nex.args[3]","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"而第二个输入则是另外一段表达式（的结果），这段表达式是* 函数的函数调用","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"ex.args[3].head\nex.args[3].args[1]\nex.args[3].args[2]\nex.args[3].args[3]","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"于是最终通过嵌套 Expr 这样的一个节点和 Symbol 类型这样的叶子节点，我们构成了一颗树。","category":"page"},{"location":"quick-start/#xxx-...-end-1","page":"快速入门","title":"xxx ... end","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"到了这里，我们就会发现在 Julia 里使用 end 作为代码块的结尾的好处了：它可以很自然地和不同的标记组合从而用较少的标记产生不同的语义。当我们写 begin ... end 的时候，我们定义了一个运行时的代码块，而当我们写 quote ... end 的时候我们将这一整段表达式单独拿了出来，到了函数定义，函数的 AST 其实只是一个由函数签名定义的表达式+一个代码块（code block）","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"dump(:(\n    function foo(x)\n        x + 1\n    end\n))","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"其中函数体实际上相当于用 quote ... end 将函数体引用起来","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"dump(\n    quote\n        x + 1\n    end\n)","category":"page"},{"location":"quick-start/#再谈谈函数-1","page":"快速入门","title":"再谈谈函数","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"在 Julia 里，函数声明是可以不用写 return 关键字的，所有的函数在没有显式（explicitly）声明 return 关键字的时候都将默认返回整段表达式中的最后一个表达式。在有了上面关于表达式的概念以后其实这样的设计有时候是很自然的。","category":"page"},{"location":"quick-start/#变量的作用域-1","page":"快速入门","title":"变量的作用域","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"变量的作用域决定了一个变量能够被访问的区域。在 Julia 里作用域分为全局作用域（global scope）和局部作用域（local scope）。","category":"page"},{"location":"workflow/#Julia-程序编写流程-1","page":"程序的编写流程","title":"Julia 程序编写流程","text":"","category":"section"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"如果你已经熟悉其它程序的编写流程，那么你可以考虑跳过这一部分，但是我还是建议你最后能够快速的过一下这部分，因为 Julia 作为一门 JIT 编译的语言，有时候在编写上，相比解释型语言会有一些明显的延迟（latency）。 下面的编写流程主要是为了帮助你绕过这个延迟的。","category":"page"},{"location":"workflow/#terminal_and_repl-1","page":"程序的编写流程","title":"终端（Terminal）和 REPL","text":"","category":"section"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"如果你使用 Windows，你可以选择忽略终端这部分","category":"page"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"如果你通过在终端输入命令 julia 或者点击 Julia 图标，打开 Julia 的编译器，你将会进入一个称为 REPL 的界面，这是“read-eval-print loop”的缩写，也就是说它提供了一个读取一小段程序，然后运行，再将程序的输出打印出来的循环。这对于调试程序，临时测试一些小的脚本来说非常方便。此外你也可以通过在 REPL 里 include(\"你的脚本.jl\")来运行你的脚本文件。","category":"page"},{"location":"workflow/#编译器（Compiler）-1","page":"程序的编写流程","title":"编译器（Compiler）","text":"","category":"section"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"但是对于完整的脚本和工程来说，REPL 并不是一个好的选择，虽然你依然可以通过 include(\"你的脚本.jl\") 来运行程序，但是通过直接执行编译器命令，你可以和 shell 脚本等工具进行交互，并且你可以很好的管理一些编译器选项。你可以通过","category":"page"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"julia 你的脚本.jl","category":"page"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"来运行一个脚本，此外 Julia 编译器还有诸多编译器选项可以通过 julia --help 来查看。","category":"page"},{"location":"workflow/#编辑器（Editor）和-集成开发环境（IDE）-1","page":"程序的编写流程","title":"编辑器（Editor）和 集成开发环境（IDE）","text":"","category":"section"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"有很多刚刚接触编程的朋友分不清楚编译器和编辑器的区别，所以我在这里简单的说明一下：编译器是负责将描述程序的文本文件，编译成机器码（或者其它格式）的“翻译机”，而编辑器则是辅助你编写程序的软件，常见的编辑器包括：vscode，atom，vim，emacs 等等。","category":"page"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"集成开发环境则是集成了一整套开发环境的软件，这包括：编辑器，编译器，调试器和用户图形界面等等工具。这其中就包括 CLion，Visual studio 等等。但是新兴的语言往往不再选择以这种方式来支持开发，原因是现代插件化的编辑器已经能够通过安装插件提供同样的功能，而开发插件也会大大降低维护的成本，并且提供了更多个性化定制的可能性。","category":"page"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"Julia 语言也是类似的，Julia 社区提供了以下这些编辑器的支持：","category":"page"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"vim/emacs\natom\nvscode\nJetbrain (CLion, PyCharm, etc.)\nctags\nnotepad++\nsublime","category":"page"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"我个人推荐不熟悉 Julia 的朋友选择 atom 上的 Juno 插件，这个插件是 Julia 社区中发展时间最长的插件，相比于其它插件也更加成熟，对画图，调试的支持也更好。其次我推荐使用 vscode，这个编辑器本身是非常优秀的作品，即便它的 Julia 插件还处于比较初步的开发阶段。另外我也推荐熟悉 Jetbrain 生态的朋友使用 Jetbrain 上的 Julia 插件，你可以通过在 CLion 或者 PyCharm 里安装这个 Julia 插件来使用它。","category":"page"},{"location":"workflow/#代码的热加载-1","page":"程序的编写流程","title":"代码的热加载","text":"","category":"section"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"由于 Julia 编译器使用了即时编译技术（JIT），在每次运行一个函数之前都会进行编译，这导致在第一次运行的时候，如果是比较大段的代码则会出现一定的延迟，此外我们也不需要频繁地退出和进入 REPL 来运行新定义的函数，所以我们需要代码的热加载。所谓热加载就是指不退出 REPL 来更新函数定义，从而加载更新后的代码。这个工具叫：Revise ","category":"page"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"安装它只需：","category":"page"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"pkg> add Revise","category":"page"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"使用方法也很简单，只要在加载你将会修改的模块前加载它即可","category":"page"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"using Revise, 你将会修改的模块","category":"page"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"当然，如果你觉得这还是很麻烦，你可以在你的 vscode 插件设置中勾选 Julia: use Revise 这个选项即可。或者将它加入你的 startup.jl文件中，这样每次启动 REPL 都会加载这个 package。","category":"page"},{"location":"before-we-start/#在开始之前-1","page":"在开始之前","title":"在开始之前","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"在正式开始学习之前，我们先来说说一些比较基本的问题。这些问题并不是很技术性，但是它能够让你日常的编码任务变得更加顺滑，也能够为你在日后遇到困难的时候提供一个寻找帮助的方向。","category":"page"},{"location":"before-we-start/#如何安装-Julia-1","page":"在开始之前","title":"如何安装 Julia","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"如何安装 Julia 呢？一般来说我个人推荐直接安装 Julia 的编译器（compiler），然后再配置好一款你喜欢的编辑器（editor）。所以我先介绍这个流程。","category":"page"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"首先去Julia 英文官网的下载页面，里面列出了一系列的下载资源。第一个是最新的稳定版本（current stable release），根据自己的系统配置选择合适的下载包即可。Linux 用户可以选择直接使用 Generic Linux Binaries。然后接下来是非常稳定的长期支持版本，目前是 v1.0.x 版本，x 代表某个小版本，它会不断更新。最后是最新的不稳定版本（nightly build），你可以通过下载它预览很多新功能，但是因为它是开发版本，所以可能有 bug，会出现莫名其妙的错误等等。","category":"page"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"Julia 编译器的版本号使用语义化版本 2.0.0进行标注，格式为 X.Y.Z，这里 X 版本在 X 大于等于 1 的时候都是兼容的，而每个次版本号 Y 则代表增加了向下兼容的功能性新增，Z是修订号，代表向下兼容的问题修正（比如某个补丁）。","category":"page"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"具体安装的细节就不同的系统而不同。","category":"page"},{"location":"before-we-start/#Linux-1","page":"在开始之前","title":"Linux","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"作为开源软件，Linux 系统可能往往是支持最好的。你仅需把这个压缩包下载下来放在你喜欢的目录下即可。为了方便我们一般会在 shell 的配置文件里添加可执行文件的路径。找到你的配置文件，例如一般 Ubuntu 默认的是 bash，","category":"page"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"cd ~","category":"page"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"然后找到 .bashrc 文件（对其它类型的 shell，比如 zsh，这个文件叫 .zshrc)，然后添加下面这样一行命令","category":"page"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"export PATH=\"<到你的bin目录路径，例如/usr/local/bin>:$PATH\"","category":"page"},{"location":"before-we-start/#macOS-1","page":"在开始之前","title":"macOS","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"macOS 实际上和 Linux 非常类似，这也就是说上面这套在 Linux 上安装 Julia 的方法也可以用在 macOS 上，但是如果你下载的是官方的 .dmg 文件，那么按照正常的 macOS 应用进行安装即可，Julia 的编译器将会出现在你的 Application 文件夹中。","category":"page"},{"location":"before-we-start/#Windows-1","page":"在开始之前","title":"Windows","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"从 Julia 官网下载操作系统对应版本的安装程序 julia-x.y.z-win64/win32.exe，选择安装路径后执行。安装完成后，将安装路径下的 <disk>:\\<install path>\\bin 添加至 Path 系统变量中。在 Windows 10 操作系统下，Path 可以在 查看高级系统设置 → 环境变量 → 系统变量 下查看并编辑。","category":"page"},{"location":"before-we-start/#从源码编译-1","page":"在开始之前","title":"从源码编译","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"对于有一定能力，和背景知识的同学，你也许会尝试从源码编译。在一些机器上，通过个性化的配置这确实有助于你获得最佳的性能。此外，由于 Julia 编译器本身自带了庞大的标准库（这包括线性代数等等），你也许并不需要使用他们，而只是想使用一个体积最小的编译器等等如此的个性化需求都可以通过从源码编译来实现。Julia 的编译器团队提供了充分多的选择来支持这些特点。","category":"page"},{"location":"before-we-start/#如何安装包（package）-1","page":"在开始之前","title":"如何安装包（package）","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"很简单，打开你的 Julia，它也称为REPL。然后按 ] 键即可进入 pkg 模式，你将会看到左边从 julia>变成了 pkg，之后输入 add XXX 即可安装名为 XXX 的包。","category":"page"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"pkg> add XXXX","category":"page"},{"location":"before-we-start/#如何获取帮助-1","page":"在开始之前","title":"如何获取帮助","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"Julia 作为一门新的编程语言，它的社区不会有老牌语言大，它在网上现成的资料不会有老牌语言多。所以遇到问题你需要知道去哪里获取相关的帮助。","category":"page"},{"location":"before-we-start/#提问的艺术-1","page":"在开始之前","title":"提问的艺术","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"在此之前，根据过去的经验，我觉得非常有必要介绍这一点。在你问问题的时候请遵守提问的艺术。这非常重要，因为方便为你解答问题的人，遵守礼仪才能让你更好的成长和获得帮助。","category":"page"},{"location":"before-we-start/#善用搜索-1","page":"在开始之前","title":"善用搜索","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"一般来说在 Google 搜索里直接输入相关的问题就可以找到你想要的答案，如果结果和 Julia 语言无关，加上 Julia 语言 或者 Julia Language 即可。但是在国内的朋友可能无法使用 Google，那么使用必应一般也能够搜索到相关的结果。中文社区同时也建立了中文论坛，网络上大部分关于 Julia 相关问题的中文回答都以论坛的帖子作为形式出现，你可以使用论坛的搜索来寻找你的问题。","category":"page"},{"location":"before-we-start/#去论坛提问-1","page":"在开始之前","title":"去论坛提问","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"Julia 的中文社区和英文社区都是比较活跃的，并且有英文论坛和中文论坛两个论坛的支持。英文论坛上的人相对更多，是大部分开发者的主要活动区域，如果你有比较复杂的问题往往可以在这里找到开发者本人的回答。如果你的英文不好，或者倾向于帮助中文世界积累更多的资料，那么中文论坛也是一个很好的选择，并且你还可以在中文论坛上找到更多针对中文用户的帮助（例如网络导致的下载问题的帮助，字符格式问题等等）。","category":"page"},{"location":"before-we-start/#去聊天室提问-1","page":"在开始之前","title":"去聊天室提问","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"我个人一般不鼓励大家去聊天室提问，因为这不利于你组织问题，方便为你解答的人。但是在聊天室提问或者讨论问题又确实是最方便的。Julia 官方使用 slack 作为聊天室，你可以通过这个地址来加入 Julia 官方的 slack 群组。此外 Julia 中文社区还有一个 QQ 群，群号是：316628299。","category":"page"},{"location":"before-we-start/#参加线下活动-1","page":"在开始之前","title":"参加线下活动","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"现在活动可能是解决问题最方便的场所，这个时候你可以当面问其它使用 Julia 的人（我们称之为 Julian），从而获得最佳的帮助效果。但是也请注意遵守下面介绍的提问的艺术。Julia 中文社区和 Julia 英文官网都经常举办相关的线下活动，每年最大的线下活动是 Julia 会议，你可以访问 Julia会议官网 获得最新的会议日程。","category":"page"},{"location":"automatic-differentiation/#自动微分-1","page":"实现你自己的自动微分","title":"自动微分","text":"","category":"section"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"自动微分（automatic differentiation）技术在机器学习里也叫做后向传播，它的原理实际上是通过记录运算顺序，利用已经定义好的导数规则，生成一个正常计算程序对偶的程序。一般来说有两种自动微分方式，一种是前向自动微分（Forward Automatic Differentiation）另外一种是后向自动微分（Reverse Automatic Differentiation），后者更加适合多参数的情况（算法细节就不详述了，多参数的时候后向自动微分的时间复杂度更低，一次传播可以计算所有的参数）。后向自动微分会将所有的操作以一张图的方式存储下来，这张图称为计算图。这也是各大深度学习框架的核心所在——如何干净地产生一个计算图，然后高效计算它。为了展示计算图是什么，我从 Cornell，CS5740，2017sp 这门课的课件里搬运了一些图，然后把他们做成了动画。动画使用纯 Julia 的框架 Luxor 制作。","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"我们以计算下面这个表达式为例：","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"y = mathbfx^T mathbfA mathbfx + mathbfb cdot mathbfx + c","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"我们将会调用这样一些 Julia 函数来计算它：","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"z_1 = x^T\nz_2 = z_1 A\ny_1 = z_2 x\ny_2 = b cdot x\ny_1 + y_2 + c","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"而实际上我们可以把这个过程画成下面的这个图","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"(Image: forward)","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"而计算这样一张图，我们将先从叶子结点开始赋值（绿色），然后依次计算相邻的节点，不断向前传播。这个过程称为前向传播过程。接下来我们按照链式法则来计算导数，每个节点返回的导数都和输入的数量相同，我们从最上面的节点开始向后传播，将当前有导数的节点标记为红色。","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"(Image: backward)","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"当红色传播到变量处时，我们就获得了变量的导数。","category":"page"},{"location":"automatic-differentiation/#动态图-VS-静态图-1","page":"实现你自己的自动微分","title":"动态图 VS 静态图","text":"","category":"section"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"按照构建计算图的方式不同，我们可以将计算图分为动态图和静态图两种，尽管在算法上并没有很大区别，但是在实现上我们可以选择在前向传播的过程中构建计算图（比如 PyTorch），也可以选择先构建计算图再计算各个节点的值（比如 tensorflow）。","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"就我个人而言，我比较喜欢 PyTorch，所以这里我将实现一个动态图。","category":"page"},{"location":"automatic-differentiation/#定义计算图中的节点-1","page":"实现你自己的自动微分","title":"定义计算图中的节点","text":"","category":"section"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"在我们开始写具体的实现之前，先来为所有的节点类型定义一个抽象类型（类似于基类）：","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"abstract type AbstractNode end","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"在 PyTorch 里，能够拥有导数的称为变量（Variable），尽管在 0.4 版本之后 Tensor 默认就是一个 Variable 了（有 requires_grad 为 True），在后端依然还有这个类型。它是对计算图构建过程中不可或缺的类型。接下来我们来定义变量（Variable）","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"mutable struct Variable{T} <: AbstractNode\n    value::T\n    grad::T\n\n    Variable(val::T) where T = new{T}(val, zero(grad))\nend","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"类似 PyTorch 一样，变量存储了值（value）和它的梯度（grad），在每一次后向传播的过程中我们将会不断地将梯度累加到这个变量的梯度上去。这里 zero 是几乎所有 Julia 数值类型都有的一个接口，它将放回对应的零元素，例如对 Float64 类型的 Julia 变量，将返回 0.0，对Array{Float64}将返回一个充满 0.0 的 Array{Float64}。","category":"page"},{"location":"automatic-differentiation/#其它节点-1","page":"实现你自己的自动微分","title":"其它节点","text":"","category":"section"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"我们现在有了变量了，也就是计算图的叶子结点，接下来还需要有中间的节点。它们将存储一个函数和它们的输入","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"struct Node{FT <: Function, ArgsT <: Tuple, KwargsT <: NamedTuple} <: AbstractNode\n    f::FT\n    args::ArgsT\n    kwargs::KwargsT\nend","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"我们这里使用参数类型，这样在将来进行分发的时候，编译器能够自己通过类型推导出要分发的函数从而提高运行时的性能。但我们应当要考虑 broadcast（广播）和正常的函数调用的区别，由于 Julia 能够对任意函数进行广播，广播时所调用的实际上是 broadcast 函数，所以我们不妨实现两个 trait 来区分这种情况：","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"abstract type Operator end\n\nmodule Trait\nimport YAAD: Operator\n\nstruct Method{FT} <: Operator\n    f::FT\nend\n\nstruct Broadcasted{FT} <: Operator\n    f::FT\nend\nend # Trait","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"这里我将这两个 trait 实现在一个 module 里面是为了能够显示地体现出他们俩是 trait，因为之后调用的时候将会写为 Trait.Method 和 Trait.Broadcasted ，他们各自存储了一个函数（注意 Julia 里每个函数都是一个 callable 的类型）。然后我们把原先 Node 类型的参数约束 Function 改成 Operator","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"struct Node{FT <: Operator, ArgsT <: Tuple, KwargsT <: NamedTuple} <: AbstractNode\n    f::FT\n    args::ArgsT\n    kwargs::KwargsT\nend","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"接下来为了方便我们来定义一些构造函数","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"# wrap function to Method\nNode(f::Function, args, kwargs) = Node(Trait.Method(f), args, kwargs)\nNode(op, args) = Node(op, args, NamedTuple())","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"第一个是因为大部分时间，我们要记录的函数就是它本身而不是一个广播，第二个是因为大部分涉及数值计算的函数都没有关键字（keyword）。实际上，Node 类型本身也只是函数和它的输入类型的一个 trait，它在计算的过程中也只是负责（静态地）分发方法。在更加高级的实现里，我们实际上有更加漂亮的实现，利用 Cassette.jl 对 Julia 代码进行非侵入式地自动微分（意思是无需给源码重载运算符，增加 Variable 类型，编译器将直接在 JIT 期间对前向传播的代码进行变换，从而直接得到计算梯度的代码）。最后，我们还需要定义一个缓存函数输出的对象，这个缓存的值将会被一些函数的导数用到","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"mutable struct CachedNode{NT <: AbstractNode, OutT} <: AbstractNode\n    node::NT\n    output::OutT\nend","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"而这个节点将在前向传播的同时被构建出来（否则我们无法知道输出的类型是什么）","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"function CachedNode(f, args...; kwargs...)\n    node = Node(f, args, kwargs.data) # this constructs a Node\n    output = forward(node)\n    CachedNode(node, output)\nend","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"我们暂且把这个接口定义为 forward（与 PyTorch 一致）","category":"page"},{"location":"automatic-differentiation/#求值-1","page":"实现你自己的自动微分","title":"求值","text":"","category":"section"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"求值是最重要的部分，因为我们需要将我们的自动微分设计地可扩展，尽量不要在扩展的时候编写冗余的代码。而在 Julia 里，我们可以利用多重派发（multiple dispatch）实现这一点。","category":"page"},{"location":"automatic-differentiation/#前向传播-1","page":"实现你自己的自动微分","title":"前向传播","text":"","category":"section"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"那么如何进行前向传播呢？这取决于对于 forward 这个抽象函数（generic function），实现了什么方法（method）：","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"如果输入是一个 Node 类型，我们将其展开","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"forward(node.f, map(forward, node.args)...; map(forward, node.kwargs)...)","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"这将使得我们多了一层插入自定义方法的接口，如果我们有一个自定义的算符，它并非一个函数，我们只需要实现对应的方法即可，例如","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"struct Linear <: Operator\n  w::Matrix{Float64}\n  b::Vector{Float64}\nend\n\n\nforward(op::Linear, x::Vector{Float64}) = op.w * x + b","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"然而对于简单的函数调用，我们并不想每次都写","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"function forward(::Method{typeof(sin)}, x)\n  sin(x)\nend","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"所以我们再实现一个默认展开 Operator 的方法","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"forward(op::Operator, args...; kwargs...) = op(args...; kwargs...)","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"这意味着只要 Operator 实现了自己的 call 方法（如果这个 Operator 类型是 callable 的），那么就无需去写别的东西，自动调用这个方法。当然我们现在要回去给 Method Trait 实现一下它的 call 方法","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"(op::Trait.Method)(args...; kwargs...) = op.f(args...; kwargs...)","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"例如，我们现在只需要定义 Linear 的 call 方法就够了","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"(op::Linear)(x::Vector) = op.w * x + op.b","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"此外，除了变量，还有一些常数例如","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"Variable(2.0) + 3.0","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"这里的 3.0 就是一个不需要求导的常数，我们原封不动地返回它，这样我们只要实现一个 value 接口来获取值即可","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"value(x) = x\nvalue(x::Variable) = x.value\nvalue(x::CachedNode) = x.output","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"然后直接调用 value","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"forward(x) = x\nforward(x::Variable) = value(x)","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"然后别忘了，对于其它类型我们返回一个友好一些的报错","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"forward(x::NT) where {NT <: AbstractNode} = error(\"forward method is not implemented for node type: $NT\")\n\nfunction value(x::T) where {T <: AbstractNode}\n    error(\n        \"Expected value in this node $x of type $T \",\n        \"check if you defined a non-cached node\",\n        \" or overload value function for your node.\"\n    )\nend","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"然后对于 Variable 和 CachedNode 我们要返回它们存储的值，好的👌，到目前为止，我们已经搞定前向传播部分了，接下来是后向传播部分。","category":"page"},{"location":"automatic-differentiation/#后向传播-1","page":"实现你自己的自动微分","title":"后向传播","text":"","category":"section"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"后向传播实际上和前向传播几乎是一样的，我们只要不断地在不同的类型标签下迭代 backward 接口即可（注意我不打算在这里实现关键词的后向传播，尽管这并不难）","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"首先，对 Variable 来说，这很简单直接加接收到的梯度就好了","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"function backward(x::Variable, grad)\n    x.grad += grad\n    nothing\nend","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"然后我们现在定义 CachedNode 的后向传播规则。我们先从一个叫 gradient 的方法里获得各个输入的导数，然后再把这些导数依次输入到输入类型对应的 backward 函数里去","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"function backward(node::CachedNode, f, grad)\n    grad_inputs = gradient(node, grad)\n    for (each, each_grad) in zip(args(node), grad_inputs)\n        backward(each, each_grad)\n    end\n    nothing\nend","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"等等，我们要在这里加一些友好的报错信息，面得以后我们自己抓狂。首先是类型的检查，这完全是静态的，所以不同担心会影响性能","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"backward_type_assert(node::CachedNode{<:AbstractNode, T}, grad::T) where T = true\nbackward_type_assert(node::CachedNode{<:AbstractNode, T1}, grad::T2) where {T1, T2} =\n    error(\"Gradient is expected to have the same\",\n          \" type with outputs, expected $T1\",\n          \" got $T2\")","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"我们在这里要求输出和梯度的类型要一样，但是对于多维数组（AbstractArray）我们只要求它们的数据类型和维度相同即可，因为有可能一些函数会返回特别优化的数组（例如稀疏数组，或者一些懒惰求值的中间结果）。","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"# exclude arrays\nbackward_type_assert(node::CachedNode{<:AbstractNode, T1}, grad::T2) where\n    {T, N, T1 <: AbstractArray{T, N}, T2 <: AbstractArray{T, N}} = true","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"然后我们还要检查梯度和输出的大小是否匹配","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"function backward_size_assert(node::CachedNode, grad)\n    size(node.output) == size(grad) ||\n        error(\n            \"gradient should have the same size with output,\",\n            \" expect size $(size(node.output)), got $(size(grad))\"\n        )\nend","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"在 Julia 里，可以通过编译选项把边界检查关掉，因为我们有时候完全不需要边界检查，你可以通过增加 @boundscheck 这个宏来实现这一点，最后我们的 backward 函数如下：","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"function backward(node::CachedNode, f, grad)\n    backward_type_assert(node, grad)\n    @boundscheck backward_size_assert(node, grad)\n\n    grad_inputs = gradient(node, grad)\n    for (each, each_grad) in zip(args(node), grad_inputs)\n        backward(each, each_grad)\n    end\n    nothing\nend","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"现在我们来考虑如何定义梯度，也就是 gradient 方法，我们依然希望不要写冗余的代码，同时保证性能和扩展性。比如，实现 sin 的导数只需要定义","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"gradient(::typeof(sin), grad, output, x) = grad * cos(x)","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"我们还是利用多重派发来实现这一点，先把 CachedNode 展开","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"gradient(x::CachedNode, grad) = gradient(x.node.f, grad, x.output, map(value, x.node.args)...; map(value, x.node.kwargs)...)","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"然后把 Operator 展开到函数上去","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"gradient(x::Trait.Method, grad, output, args...; kwargs...) =\n    gradient(x.f, grad, output, args...; kwargs...)","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"最后定义一个报错信息","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"gradient(fn, grad, output, args...; kwargs...) =\n    error(\n        \"gradient of operator $fn is not defined\\n\",\n        \"Possible Fix:\\n\",\n        \"define one of the following:\\n\",\n        \"1. gradient(::typeof($fn), grad, output, args...; kwargs...)\\n\",\n        \"2. gradient(op::Trait.Method{typeof($fn)}, grad, output, args...; kwargs...)\\n\",\n        \"3. gradient(op::Trait.Broadcasted{typeof($fn)}, grad, output, args...; kwargs...)\\n\"\n    )","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"这样，我们就可以选择不同的 gradient 接口来实现导数，Julia 将自动派发你实现的这个方法，例如","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"# I re-define the concrete type `Linear` here in order to store the gradient\nstruct Linear <: Operator\n  w::Variable{Matrix{Float64}}\n  b::Variable{Vector{Float64}}\nend\n\nfunction gradient(op::Linear, grad, output, x)\n  grad_w, grad_b = # some gradient expression to calculate the gradient of w and b\n  backward(op.w, grad_w) # update gradient of w\n  backward(op.w, grad_b) # update gradient of b\n\n  grad_input = # calculate the gradient of input\n  grad_input # return the gradient of input\nend","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"最后我们定义一个 register 的接口用来产生 CachedNode","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"register(f, args...; kwargs...) = CachedNode(f, args...; kwargs...)","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"这样我们就可以通过重载函数/运算符来构建计算图了","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"Base.sin(x::AbstractNode) = register(Base.sin, x)\ngradient(::typeof(Base.sin), grad, output, x) = (grad * cos(x), )","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"不过等等，似乎这里有时候需要判断一下输入是什么类型比较好，我们不妨为 Variable 和 CachedNode 定义一个抽象类型 Value","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"abstract type Value{T} <: AbstractNode end","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"Value 类型将带有其子类型的值的类型 T 作为其参数。现在先回去修改 Variable 和 CachedNode","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"mutable struct Variable{T} <: Value{T}\n    value::T\n    grad::T\n\n    Variable(val::T) where T = new{T}(val, zero(grad))\nend\n\nmutable struct CachedNode{NT <: AbstractNode, OutT} <: Value{OutT}\n    node::NT\n    output::OutT\nend","category":"page"},{"location":"automatic-differentiation/#广播-1","page":"实现你自己的自动微分","title":"广播","text":"","category":"section"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"然而上面的定义还只能给标量用，对于数组我们还需要广播才行。Julia 自己实现了一套广播系统，它能够广播任何 Julia 函数到数组上，会融合多个被广播的函数（从而产生更优质的向量化 SIMD 代码），同时还允许定义广播的行为。这恰好就是我们需要的：我们要在广播的同时产生一个计算图，记录这个操作。首先我们定义我们自己的广播风格（BroadcastStyle）：","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"struct ComputGraphStyle <: Broadcast.BroadcastStyle end\nBase.BroadcastStyle(::Type{<:AbstractNode}) = ComputGraphStyle()\nBroadcast.BroadcastStyle(s::ComputGraphStyle, x::Broadcast.BroadcastStyle) = s","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"这还不够，Julia 的 broadcast 是懒惰求值的，它先通过 broadcasted 方法构建中间类型，然后再在最后通过 materialize 方法进行求值。我们还需要让它们也被记录在计算图里","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"function Broadcast.broadcasted(::ComputGraphStyle, f, args...)\n    mt = Trait.Broadcasted(f)\n    register(mt, args...)\nend\n\nBroadcast.materialize(x::AbstractNode) = register(Broadcast.materialize, x)","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"然后我们让 materialize 在后向传播的时候直接返回梯度","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"function backward(node::CachedNode, ::typeof(Broadcast.materialize), grad)\n    backward_type_assert(node, grad)\n    @boundscheck backward_size_assert(node, grad)\n    backward(node.node.args[1], grad) # materialize only has one arguments, we don't need the for loop\nend","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"然而这时，Broadcasted 类型的 backward 会调用默认的 CachedNode 的 backward 方法，有时就会因为类型不同报错（因为我们之前这么定义了）我们为这个类型开个后门","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"function backward(node::CachedNode, ::Trait.Broadcasted, grad)\n    grad_inputs = gradient(node, grad)\n    for (each, each_grad) in zip(args(node), grad_inputs)\n        backward(each, each_grad)\n    end\n    nothing\nend","category":"page"},{"location":"automatic-differentiation/#免费获得更多的算符-1","page":"实现你自己的自动微分","title":"免费获得更多的算符","text":"","category":"section"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"Julia 有一个包叫做 DiffRules.jl，它记录了大量常用算符的导数规则，并且这些导数规则都以 Julia 表达式的方式记录，这意味着我们可以利用元编程批量生产算符。这些导数规则都在一个常数列表里，名为DiffRules.DEFINED_DIFFRULES，我们遍历它即可","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"for (mod, name, nargs) in keys(DiffRules.DEFINED_DIFFRULES)\n  # code generation\nend","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"这里 mod 是 module 的名字，name 是函数的名字，nargs 是函数输入变量的个数，然后我们就可以用如下的方式来批量产生这些导数的定义","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"for (mod, name, nargs) in keys(DiffRules.DEFINED_DIFFRULES)\n    f_ex_head = Expr(:., mod, QuoteNode(name))\n\n    if nargs == 1\n        df_ex = DiffRules.diffrule(mod, name, :x)\n\n        name === :abs && continue # exclude abs, it cannot be directly broadcasted\n\n        @eval begin\n            $(f_ex_head)(x::AbstractNode) = register($(f_ex_head), x)\n            gradient(::typeof($(f_ex_head)), grad, output, x) = (grad * $df_ex, )\n            gradient(mt::Trait.Broadcasted{typeof($f_ex_head)}, grad, output, x) = (@.(grad * $(df_ex)), )\n        end\n    elseif nargs == 2\n        df_ex = DiffRules.diffrule(mod, name, :x, :y)\n\n        @eval begin\n\n            $(f_ex_head)(x1::AbstractNode, x2) = register($f_ex_head, x1, x2)\n            $(f_ex_head)(x1, x2::AbstractNode) = register($f_ex_head, x1, x2)\n            $(f_ex_head)(x1::AbstractNode, x2::AbstractNode) = register($f_ex_head, x1, x2)\n\n            gradient(::typeof($f_ex_head), grad, output, x, y) =\n                (grad * $(df_ex[1]), grad * $(df_ex[2]))\n            gradient(::Trait.Broadcasted{typeof($f_ex_head)}, grad, output, x, y) =\n                (@.(grad * ($(df_ex[1]))), @.(grad * $(df_ex[2])))\n        end\n    else\n        @info \"unknown operator $name\"\n    end\nend","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"对如何使用代码生成，我建议你阅读 Julia 的文档：元编程 · Julia中文文档 。我在这里跳过了 abs 函数是因为批量广播的宏不能对 if else 进行广播。我们需要单独去定义 abs 的导数，但是剩下几乎所有的数学函数都用 Diffrules 生成了。","category":"page"},{"location":"automatic-differentiation/#代码修饰-1","page":"实现你自己的自动微分","title":"代码修饰","text":"","category":"section"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"之后我又花了一些时间实现仿照 PyTorch 了一个计算 Jacobbian 的函数用来做单元测试。然后利用 Trait 将数组类型的 Variable 重新插入 AbstractArray 的类型树中以实现更好的打印信息。","category":"page"},{"location":"automatic-differentiation/#性能对比-1","page":"实现你自己的自动微分","title":"性能对比","text":"","category":"section"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"好了！到此我们就写完了这个自动微分库了，它的性能怎么样呢？我起初以为这么简单的一个实现只是一个玩具，但实际上它的性能非常不错！我需要计算一个称为 MPS 的东西（Matrix product state），所以我在这里使用了我使用最频繁的操作进行 benchmark，这个操作是 tr(x1 * x2) ，这里 x1 和 x2 是矩阵，然后对其求迹。","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"所以我首先为 YAAD 实现了这两个算符：","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"# 这一部分其实已经在 DiffRules 进行代码生成的时候定义过了\nBase.:(*)(lhs::Value, rhs) = register(Base.:(*), lhs, rhs)\nBase.:(*)(lhs, rhs::Value) = register(Base.:(*), lhs, rhs)\nBase.:(*)(lhs::Value, rhs::Value) = register(Base.:(*), lhs, rhs)\n\n# 这里开始是新的定义\nusing LinearAlgebra\n\nLinearAlgebra.tr(x::Value) = register(LinearAlgebra.tr, x)\ngradient(::typeof(tr), grad, output, x) = (grad * Matrix(I, size(x)), )\n\nfunction gradient(::typeof(*), grad, output, lhs::AbstractVecOrMat, rhs::AbstractVecOrMat)\n    grad * transpose(rhs), transpose(lhs) * grad\nend","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"julia","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"然后我选取了几个 Julia 的库（Zygote，Flux，YAAD 是我的），还有 PyTorch 在 CPU 上进行了一下比较","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"Zygote.@grad LinearAlgebra.tr(x) = LinearAlgebra.tr(x), Δ-> (Δ * Matrix(I, size(x)), )\n\nfunction bench_tr_mul_yaad(x1, x2)\n    z = tr(x1 * x2)\n    YAAD.backward(z)\n    x1.grad, x2.grad\nend\n\nfunction bench_tr_mul_autograd(x1, x2)\n    z = AutoGrad.@diff tr(x1 * x2)\n    AutoGrad.grad(z, x1), AutoGrad.grad(z, x2)\nend\n\nfunction bench_tr_mul_zygote(x1, x2)\n    Zygote.gradient((x1, x2)->tr(x1 * x2), x1, x2)\nend\n\nfunction bench_tr_mul_flux(x1, x2)\n    z = tr(x1 * x2)\n    Flux.Tracker.back!(z, 1)\n    x1.grad, x2.grad\nend","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"然后在 Python 里测试 PyTorch（我们的接口和 PyTorch 非常相似不是吗？）","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"def bench_tr_mul_torch(x1, x2):\n    z = torch.trace(torch.matmul(x1, x2))\n    z.backward()\n    return x1.grad, x2.grad","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"然后输入定义如下：","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"xv, yv = rand(30, 30), rand(30, 30)\nyaad_x, yaad_y = YAAD.Variable(xv), YAAD.Variable(yv)\nautograd_x, autograd_y = AutoGrad.Param(xv), AutoGrad.Param(yv)\nflux_x, flux_y = Flux.param(xv), Flux.param(yv)","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"此外，在进行测试之前，我们实现一个手动计算梯度的版本作为基准：","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"function bench_tr_mul_base(x1, x2)\n    z1 = x1 * x2\n    z2 = tr(z1)\n\n    grad_z1 = Matrix{eltype(z1)}(I, size(z1))\n    grad_z1 * transpose(x2), transpose(x1) * grad_z1\nend","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"然后在 Julia 里我们用 @benchmark 宏来多次测量以获取运行时间","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"julia> @benchmark bench_tr_mul_autograd(autograd_x, autograd_y)\nBenchmarkTools.Trial:\n  memory estimate:  33.20 KiB\n  allocs estimate:  82\n  --------------\n  minimum time:     50.218 μs (0.00% GC)\n  median time:      62.364 μs (0.00% GC)\n  mean time:        90.422 μs (9.86% GC)\n  maximum time:     55.386 ms (99.86% GC)\n  --------------\n  samples:          10000\n  evals/sample:     1\n\njulia> @benchmark bench_tr_mul_yaad(yaad_x, yaad_y)\nBenchmarkTools.Trial:\n  memory estimate:  51.50 KiB\n  allocs estimate:  16\n  --------------\n  minimum time:     10.387 μs (0.00% GC)\n  median time:      13.429 μs (0.00% GC)\n  mean time:        24.273 μs (45.13% GC)\n  maximum time:     55.963 ms (99.96% GC)\n  --------------\n  samples:          10000\n  evals/sample:     1\n\njulia> @benchmark bench_tr_mul_zygote(xv, yv)\nBenchmarkTools.Trial:\n  memory estimate:  29.98 KiB\n  allocs estimate:  10\n  --------------\n  minimum time:     42.527 μs (0.00% GC)\n  median time:      46.640 μs (0.00% GC)\n  mean time:        56.996 μs (15.31% GC)\n  maximum time:     51.718 ms (99.90% GC)\n  --------------\n  samples:          10000\n  evals/sample:     1\n\njulia> @benchmark bench_tr_mul_base(xv, yv)\nBenchmarkTools.Trial:\n  memory estimate:  28.78 KiB\n  allocs estimate:  5\n  --------------\n  minimum time:     6.413 μs (0.00% GC)\n  median time:      8.201 μs (0.00% GC)\n  mean time:        12.215 μs (31.57% GC)\n  maximum time:     11.012 ms (99.87% GC)\n  --------------\n  samples:          10000\n  evals/sample:     5\n\njulia> @benchmark bench_tr_mul_flux(flux_x, flux_y)\nBenchmarkTools.Trial:\n  memory estimate:  30.25 KiB\n  allocs estimate:  24\n  --------------\n  minimum time:     8.009 μs (0.00% GC)\n  median time:      10.002 μs (0.00% GC)\n  mean time:        14.412 μs (30.14% GC)\n  maximum time:     16.286 ms (99.87% GC)\n  --------------\n  samples:          10000\n  evals/sample:     3","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"然后 PyTorch (0.4.1) 上","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"In [4]: x = torch.rand(30, 30, dtype=torch.float64, requires_grad=True)\n\nIn [5]: y = torch.rand(30, 30, dtype=torch.float64, requires_grad=True)\n\nIn [6]: %timeit bench_tr_mul_torch(x, y)\n76.8 µs ± 1.68 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"所以我们花了小半天实现的这个自动微分还不赖嘛？只比基准性能满了几个微秒，意外的是它竟然比 PyTorch 快了不少。然后 Flux 的 Tracker 性能竟然非常接近手动求导！","category":"page"},{"location":"define-your-own-matrix/#实现你自己的稀疏矩阵-1","page":"实现你自己的稀疏矩阵","title":"实现你自己的稀疏矩阵","text":"","category":"section"},{"location":"define-your-own-matrix/#","page":"实现你自己的稀疏矩阵","title":"实现你自己的稀疏矩阵","text":"Julia 语言有着世界上最好的矩阵和数组生态，这得益于 Julia 语言的类型系统（type system）和多重派发（multiple dispatch）。在这一部分，我们将通过自己实现一个稀疏矩阵类型来体验这一点。","category":"page"},{"location":"define-your-own-matrix/#一些关于稀疏矩阵的基础知识-1","page":"实现你自己的稀疏矩阵","title":"一些关于稀疏矩阵的基础知识","text":"","category":"section"},{"location":"define-your-own-matrix/#","page":"实现你自己的稀疏矩阵","title":"实现你自己的稀疏矩阵","text":"我们这里所说的稀疏矩阵是指能够表示任意含有大量零元素的矩阵的数据结构。一般来说有这样几种数据结构","category":"page"},{"location":"define-your-own-matrix/#COO-格式-1","page":"实现你自己的稀疏矩阵","title":"COO 格式","text":"","category":"section"},{"location":"define-your-own-matrix/#","page":"实现你自己的稀疏矩阵","title":"实现你自己的稀疏矩阵","text":"这是最简单直接的格式，我们将每个非零元素的值，坐标存到一个表里。一般用于高效地构造矩阵。","category":"page"},{"location":"define-your-own-matrix/#CSC-格式-1","page":"实现你自己的稀疏矩阵","title":"CSC 格式","text":"","category":"section"},{"location":"define-your-own-matrix/#","page":"实现你自己的稀疏矩阵","title":"实现你自己的稀疏矩阵","text":"CSC 是 Compressed Sparse Column 的缩写，一些实现里也使用 CSR 格式也就是Compressed Sparse Row。","category":"page"},{"location":"define-your-own-matrix/#Julia-语言中的接口定义（Interface）-1","page":"实现你自己的稀疏矩阵","title":"Julia 语言中的接口定义（Interface）","text":"","category":"section"},{"location":"define-your-own-matrix/#Julia-语言中的广播机制-1","page":"实现你自己的稀疏矩阵","title":"Julia 语言中的广播机制","text":"","category":"section"},{"location":"define-your-own-matrix/#Holy-Trait-1","page":"实现你自己的稀疏矩阵","title":"Holy Trait","text":"","category":"section"},{"location":"#Julia-编程指南-1","page":"简介","title":"Julia 编程指南","text":"","category":"section"},{"location":"#","page":"简介","title":"简介","text":"Julia 语言在 2018 年正式发布了第一个长期支持版本（1.0 版本），在这之后市面上出现了很多中文教程。但是，为什么我还要编写本书呢？有如下的一些原因：","category":"page"},{"location":"#","page":"简介","title":"简介","text":"市面上的中文书籍和教程主要都以入门 Julia 语言为主。但是还没有一本由有经验的 Julia 语言开发者所编写的书籍。\n我们在中文社区的论坛，QQ 群等中文媒体上经常可以看到中文用户抱怨没有好的教材可以参考，缺乏可以学习的代码范例，并且中文网络上依然大量充斥着旧版 Julia 的代码（Julia 0.6 甚至是更加古老的版本）。这些旧的代码随着 1.0 版本的发布已经不再支持，对很多 Julia 学习者造成了困扰。\n我发现由于 Julia 语言编程范式和其它流行语言（例如 Python，C++，MATLAB）有很大不同，有很多 Julia 学习者在阅读过文档之后，即便已经学会了基本语法，大部分 Julia 学习者入门之后依然无法很好的编写一个完整的，符合 Julia 范式的代码库。\n我们有时候还是需要一些文档里不会讲的内容，比如一些经验性质的总结，一些更加和某个领域相关的完整工程展示。所以这也是这本书的目的之一：提供编写 Julia 工程的实践范例\n我在知乎上写过很多零散的关于 Julia 语言的文章，有很多人建议我将它们整理到一起，但是我不是很喜欢知乎的编辑器，它并不适合编写长篇的技术文章，对数学公式和代码的支持非常差。而微信公众号则更加糟糕，在经过调研后我觉得还是需要使用开源工具自己来做这件事情。\n大部分的书籍依然是传统的纸质媒体，或者以纸质媒体为前提进行编写。这在现在这个互联网和富文本时代是非常落后的。我希望以此为媒介，做一些现代书籍的实验。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"本书使用纯 Julia 进行编写，除了构成静态网页的 JS/HTML/CSS 脚本以外，这本书的 Julia 纯度为：100%，当你下载这本书之后，可以用 Julia 的编译器运行下面这行命令","category":"page"},{"location":"#","page":"简介","title":"简介","text":"在命令行里","category":"page"},{"location":"#","page":"简介","title":"简介","text":"julia make.jl serve","category":"page"},{"location":"#","page":"简介","title":"简介","text":"或者打开 Julia 的 REPL，然后运行","category":"page"},{"location":"#","page":"简介","title":"简介","text":"include(\"make.jl\")","category":"page"},{"location":"#","page":"简介","title":"简介","text":"这本书就会以网页的形式挂在到 localhost:8000，它使用了 Documenter 和 LiveServer 这两个 Julia 包进行编译和挂载。如果你喜欢黑夜模式（dark mode）你还可以点击右上角的齿轮按钮选择黑夜模式。","category":"page"},{"location":"#Julia-语言的定位是什么？-1","page":"简介","title":"Julia 语言的定位是什么？","text":"","category":"section"},{"location":"#","page":"简介","title":"简介","text":"Julia 是主要用来做科学计算吗？是的，Julia 主要用来做科学/技术计算（Scientific Computing），实际上在 1.0 以前 Julia 的 REPL 启动之后都有一句：A Fresh Approach To Technical Computing。这意味着社区的主要关注点在科学计算上，但这不是说 Julia 只能做科学计算。实际上构建网站，挖比特币，图形界面等等都有相关的 package。但是我们说社区的主要关注点在科学计算，所以相比诸如 Python/Go/Erlang 的这些类似功能，Julia 的这些功能更多的是为了服务于科学计算，而不是和已有的软件同台竞争。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"但 Julia 本身的定位和很多其它语言一样：一个通用编程语言。","category":"page"},{"location":"#为什么要设计一个新语言？原先的解决方案有什么问题？-1","page":"简介","title":"为什么要设计一个新语言？原先的解决方案有什么问题？","text":"","category":"section"},{"location":"#","page":"简介","title":"简介","text":"我知道很多人提到 Julia 都想到性能。但是我不想从性能讲，因为 Julia 并不单纯的是要解决性能问题，Julia 要解决的是一个有前提的性能问题：如何在让程序足够通用（generic）的前提下，尽可能提供最好的性能。Julia 为了解决这个问题成为了第一个为 JIT 编译设计的语言，也是第一个实现了高性能的多重派发（multiple dispatch）的语言。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"当你开始使用 Julia 以后，你会发现不同于 Python/MATLAB/C++/C 的是，大部分时候我们只要关心数学对象，我们写的代码都非常的 generic，于是非常多的功能通过多重派发和类型系统只要数学上讲得通，就自动工作了，不需要写额外的代码把他们组合在一起。例如曾经在社区里发生过一个很经典的事情：DifferentialEquations 的作者有一天发现，有一个他完全不认识的人写了一个误差分析的库（Measurements），定义了一种数，带误差上下界，结果放进微分方程的求解器里什么都没有算，就自动能够工作用来分析误差。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"所以有很多 Julia 用户的观点是：即便 Julia 的性能不好（其实挺不错的），这种新的编程范式本身就足够吸引人了。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"这个问题我在之后还会更加详细的以长篇幅讨论，如果你想现在阅读也可以直接跳到这部分：","category":"page"},{"location":"#Julia-官方宣称自己很快，但是再快能有-C/C/Fortran-快吗？-1","page":"简介","title":"Julia 官方宣称自己很快，但是再快能有 C/C++/Fortran 快吗？","text":"","category":"section"},{"location":"#","page":"简介","title":"简介","text":"首先我们要解释一下误区，我遇到过很多人都持有这样的观点：如果我用一个静态编译语言实现我的功能，它就会很快。这是错误的，一段代码快不快并不取决于它使用什么语言编写，而是取决于它具体做了什么，它所实现的算法时间复杂度是多少。在很多情况下，用静态语言写的实现更快只是因为静态语言的编译机制强制你写出能够被编译器充分优化的代码（但有时候也许没有必要）。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"比如 AutoTVM 可以用 Python 的 API 找出一个比 MKL 快的 kernel，这个算不算 Python 更快呢？所以实际上，如果你不在乎性能，Julia 可以像 Python 解释器一样慢，但是如果你在乎性能，不同于 Python 的是 Julia 也为优化提供了充分的可能性。例如你可以用纯 Julia，以高级语言的特性实现 BLAS 的 gemm routine，它的性能可以接近手工调整汇编指令的 OpenBLAS。而注意这个矩阵乘法的实现本身是一般的，它没有用到任何特殊的语义，它是使用 Julia 本身的语法表达了矩阵的分块等语义。也就是说它不仅可以使用 32 和 64 位浮点，对于其它的 Julia 类型也能够工作。这就是我们说的在代码足够一般的前提下，依然能够获得非常好的性能。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"(Image: JuliaBLAS-benchmark)","category":"page"},{"location":"#","page":"简介","title":"简介","text":"矩阵乘法能够在一定程度上说明即便是稍微复杂一些的任务，Julia 也能够拥有不错的性能。而实际上由于社区本身对科学计算的重视，我们会发现当我们实现一个完整的工程之后，往往要比同类软件的 C++ 版本快。这往往是因为在 Julia 里已经有了丰富的基础生态（例如各种特殊矩阵算法的实现，各种线性代数算法的实现）同时实现各种特化的算法代价又非常的低，同样的接口组合下不同的类型就可以了，最后导致的结果就是即便编译器本身做的优化并不如 GCC/Clang，最终的效果却可能更快。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"当然了，说到这里有人可能还是不信，我最近刚好在给我们的量子计算框架做 benchmark，其中 ProjectQ 是一个非常标准的 pybind11 C++/Python 程序，使用了 C++ 大量优化了性能，并且是第一个实现量子霸权模拟（45 比特的全概率幅模拟）的软件。而 qulacs 和 QuEST 则是使用了大量 C++ 进行优化了的高性能模拟器。但是我们依然能够通过精心设计的软件架构，大量的使用通用性的特化代码，用纯 Julia 就实现了更好的性能和更多的功能","category":"page"},{"location":"#","page":"简介","title":"简介","text":"(Image: parameterized)","category":"page"},{"location":"#","page":"简介","title":"简介","text":"而实际的代码量却远远小于 C++ 的实现。","category":"page"},{"location":"#既然多重派发这么好，为什么在-Julia-之前没有语言大规模使用？-1","page":"简介","title":"既然多重派发这么好，为什么在 Julia 之前没有语言大规模使用？","text":"","category":"section"},{"location":"#","page":"简介","title":"简介","text":"实际上并不是这样，在 Julia 之前有非常多的语言社区都尝试实现过多重派发，甚至曾经出现过以多重派发为主要范式的语言。但是他们都有一个严重的问题：这些多重派发的实现性能都不好，以至于最终无法应用到实际的生产环境里去。Julia 的出现也是站在这些前辈的探索之上的。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"那么 Julia 是如何解决这个问题的呢？这要说到 Julia 最大的特点：对 JIT 编译友好的语言设计。Julia 在设计之初就以 JIT 编译为假定，而非解释执行或者静态编译（AOT）。完整的多重派发本身是一种动态特性，这是因为变量的类型并不一定能够完全在编译时期确定，所以我们也说类似 C++ 的函数重载是静态的多重派发，但是 C++ 本身并不支持动态的多重派发，实现类似的功能需要虚表。而 Python 社区里也有多重派发的实现，但是 Python 由于本身是以解释器为基础设计的，所以这些多重派发的实现本质上也都只是存储了一个动态的方法表，然后在运行时期来查找。这就导致性能甚至比使用 Python 自带的 class 的单重派发 + 继承还差。类似的在其它语言里也有类似的实现，他们或者因为静态编译，对动态的多重派发支持不好，或者因为本身是动态地解释执行，最终的性能很差。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"而 Julia 通过结合 JIT 解决了这个问题，Julia 的编译过程是动态的，每次编译发生在函数被调用之前。这就意味着当编译器能够正确推导出类型的时候，我们就可以进行静态派发，当编译器无法推导类型的时候，我们自动进行动态派发。这表现为 Julia 语言的类型稳定性（type stability）。而所有的编译都以函数为界。这也就是说，如果函数 f1 是类型不稳定的，但是实际的程序中它的输出输入到一个类型稳定的函数 f2 里，Julia 依然能够被静态编译 f2，使得 f2 内部的函数派发变成静态的。","category":"page"},{"location":"#Julia-解决了什么问题？-1","page":"简介","title":"Julia 解决了什么问题？","text":"","category":"section"},{"location":"#","page":"简介","title":"简介","text":"想想我们一开始为什么会用 Python/MATLAB，他们起初也没什么生态不是么？但是它们在十年二十年前解决了科学计算的什么痛点呢？用 Fortran95 或者 C/C++（除去 C++11 以后的版本，这个后面另外讨论）写出来的代码通用性差，往往只能针对特别的问题，编写程序的过程中，因为要不断的考虑类型的问题，我们往往花了很多的时间在思考如何写出能够让编译器通过的代码这件事上。而且非常多的场景下，我们只是需要一个类似计算器的东西，给你几个矩阵，告诉我结果就行了。我们不想去思考内存布局，类型是 A<Float32, Int> 还是 B<Float32, C<Float32>> 。甚至连面向对象都懒得管。至于具体的语法细节，什么 goto，范型等其实都不是那么的重要（有很多替代方案），甚至如果你想在 Fortran95 中使用泛型（generic type）都是可能的。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"Python/MATLAB 通过使用动态性，在一定程度上解决了以上问题。它们都可以简单地被当作计算器来用，快速的告诉你想知道事情，而不需要在乎类型推导是否能够通过，也不需要等待重新编译的时间。而说到底在我们编写的很多程序中，有一大部分的性能是无所谓的，我们只需要一些关键的地方足够快就行了，所以解释执行也是没有关系的。而 Python 本身的 class 实际上由于其动态性，它可以被当成鸭子类型（duck type）来使用的。每个 class 都可以动态的插入方法。所以当我们判断一个类型是什么的时候我们不再考虑这是什么类型，而是相对的考虑这个类型能做什么事情。这为很多代码带来很强的通用性，这意味着我不必在乎这个类型是谁的子类，反正它能做这件事（比如某个类型是具有对称性的，它是一个 Hermitian 的算符），那它就能够输入给任何只使用这个接口的函数。如果我写着写着，突然发现我需要用这个方法，我临时往我的类型里插入这个 API 也都是可以的。这是 Python 的动态性带来的方便之处。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"再比如，如果有在诸如 C++ 这类静态语言里实现过多维数组的同学也许会注意到，我们很多时候希望能够在模板参数里带上一个维度作为参数，这样可以利用类型推导减少很多不必要的 check，以及保证程序的正确性，并且通过对类型参数的特化来派发一些针对性的优化，甚至更加激进一些，我们可以把 shape 也放进模板里，这样在维度不大的时候展开 for 循环，手动编写针对小矩阵的优化。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"但是这样的静态特性在使用的时候又反而带来不方便，强制运行的类型推导有时候给一些小任务带来了很大的负担。例如我们很多人都用过 Python 的 numpy，里面有一个 einsum 的功能，它提供了爱因斯坦求和标记来计算多个高维张量（也就是ndarray）的缩并，或者说求和。那么这个计算结果是一个张量，这个张量的大小和维度信息有可能是动态计算出来的，也有可能是能够在编译时期推导出来的。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"这在 Fortran 和 C/C++ 里都是不行的或者说想要实现类似的特性是更加麻烦的。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"但是，对性能需求大的部分，我们就需要精心设计了，过于动态的语义虽然方便，但是它使得编译器能够做的假设就更少。而编译器想要优化代码，必须要有足够的假设来证明优化前后的代码是等价的才行。所以我们选择用语义上能够提供这些信息给编译器的语言来编写。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"这就是著名的两语言问题。我们用一种脚本语言提供方便的接口，用一个静态语言编写有性能需求的地方。这确实在很长一段时间，甚至直到现在都能够很好的解决很多问题。但是同时也造成了很多的问题，尤其是代码的通用性。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"例如，我们在 MATLAB 或者 Python 的 CPU 上的矩阵乘法往往是通过调用使用汇编优化的，这些代码分别针对两种浮点数（32 和 64）进行了优化。但是它们不能在其它类型上工作，并且组合不同类型的矩阵，由于缺乏足够一般（generic）的实现，导致我们需要大量的人工工作。但是反观 Julia，一个典型的例子就是大量的自定义数组。我常常说：Julia 有现在所有语言里最好的矩阵和多维数组生态。让我简单列举一下：","category":"page"},{"location":"#标准库-1","page":"简介","title":"标准库","text":"","category":"section"},{"location":"#","page":"简介","title":"简介","text":"LinearAlgebra：定义了几个常用的矩阵类型 Hermitian，Symmetric，Diagonal","category":"page"},{"location":"#特殊数组-1","page":"简介","title":"特殊数组","text":"","category":"section"},{"location":"#","page":"简介","title":"简介","text":"StaticArrays：栈上的静态数组，通过编译器提供高性能的小矩阵计算\nFillArrays：一些特殊的稀疏矩阵，例如零矩阵，全是某个数的矩阵等等\nInfiniteArrays：无穷维矩阵/数组\nBlockArrays：分块数组\nLazyArrays：懒惰求值的Array\nAxisArrays：每个维度可以带标签的数组（也就是 PyTorch 所谓的 NamedTensor）","category":"page"},{"location":"#特殊矩阵（2-维数组）-1","page":"简介","title":"特殊矩阵（2 维数组）","text":"","category":"section"},{"location":"#","page":"简介","title":"简介","text":"ToeplitzMatrices \nBandedMatrices\nSpecialMatrices：这个包里实现了一些特殊矩阵，包括 Cauchy，Circulant，Campanian，Frobenius等十一种特殊矩阵（太多了就不一一列举了）\nCovarianceMatrices\nLuxurySparse（这是我们自己开发的）：PermMatrix（广义交换矩阵），各种静态数组和上面的特殊矩阵组合的一些特化的实现","category":"page"},{"location":"#针对分布式和多进程的数组-1","page":"简介","title":"针对分布式和多进程的数组","text":"","category":"section"},{"location":"#","page":"简介","title":"简介","text":"SharedArray：标准库，可以在进程中共享内存\nDistributedArray：分布式的（稠密）数组，支持一些基本操作例如分布式乘法","category":"page"},{"location":"#","page":"简介","title":"简介","text":"为什么会有这么多矩阵和数组，因为在 Julia 里实现一个特殊矩阵的代价非常低，我们很容易就能做到让一个新的矩阵类型加入到整个生态里去，然后拥有包括基本的线性代数在内的各种功能。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"而这些数组和矩阵并没有特别地为很多其它算法实现什么，例如指数矩阵乘向量（expv）算法在 ExponentialUtils 里只假定这是一个数学上讲得通的线性映射，只要你能使用乘法，那么就可以在这个算法里运行，并且编译器会通过类型推导特化你的代码，从而获得最优的性能。而作者在实现 ExponentialUtils 的时候并不需要知道这个具体是一个什么矩阵。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"所以多重派发是 Julia 高性能的基石，也是为什么大家喜欢用 Julia 写科学计算代码的主要原因之一。它确实大大降低了工作量。","category":"page"}]
}
