<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>å®ç°ä½ è‡ªå·±çš„è‡ªåŠ¨å¾®åˆ† Â· Juliaç¼–ç¨‹æŒ‡å—</title><link rel="canonical" href="https://rogerluo.me/Brochure.jl/dev/automatic-differentiation/index.html"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Juliaç¼–ç¨‹æŒ‡å—</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">ç®€ä»‹</a></li><li><a class="tocitem" href="../before-we-start/">åœ¨å¼€å§‹ä¹‹å‰</a></li><li><a class="tocitem" href="../workflow/">ç¨‹åºçš„ç¼–å†™æµç¨‹</a></li><li><a class="tocitem" href="../quick-start/">å¿«é€Ÿå…¥é—¨</a></li><li><a class="tocitem" href="../define-your-own-matrix/">å®ç°ä½ è‡ªå·±çš„ç¨€ç–çŸ©é˜µ</a></li><li class="is-active"><a class="tocitem" href>å®ç°ä½ è‡ªå·±çš„è‡ªåŠ¨å¾®åˆ†</a><ul class="internal"><li><a class="tocitem" href="#åŠ¨æ€å›¾-VS-é™æ€å›¾-1"><span>åŠ¨æ€å›¾ VS é™æ€å›¾</span></a></li><li><a class="tocitem" href="#å…¶å®ƒèŠ‚ç‚¹-1"><span>å…¶å®ƒèŠ‚ç‚¹</span></a></li><li><a class="tocitem" href="#æ±‚å€¼-1"><span>æ±‚å€¼</span></a></li><li><a class="tocitem" href="#åå‘ä¼ æ’­-1"><span>åå‘ä¼ æ’­</span></a></li><li><a class="tocitem" href="#ä»£ç ä¿®é¥°-1"><span>ä»£ç ä¿®é¥°</span></a></li><li><a class="tocitem" href="#æ€§èƒ½å¯¹æ¯”-1"><span>æ€§èƒ½å¯¹æ¯”</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>å®ç°ä½ è‡ªå·±çš„è‡ªåŠ¨å¾®åˆ†</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>å®ç°ä½ è‡ªå·±çš„è‡ªåŠ¨å¾®åˆ†</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Roger-luo/Brochure.jl/blob/master/src/automatic-differentiation.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="è‡ªåŠ¨å¾®åˆ†-1"><a class="docs-heading-anchor" href="#è‡ªåŠ¨å¾®åˆ†-1">è‡ªåŠ¨å¾®åˆ†</a><a class="docs-heading-anchor-permalink" href="#è‡ªåŠ¨å¾®åˆ†-1" title="Permalink"></a></h1><p>è‡ªåŠ¨å¾®åˆ†ï¼ˆautomatic differentiationï¼‰æŠ€æœ¯åœ¨æœºå™¨å­¦ä¹ é‡Œä¹Ÿå«åšåå‘ä¼ æ’­ï¼Œå®ƒçš„åŸç†å®é™…ä¸Šæ˜¯é€šè¿‡è®°å½•è¿ç®—é¡ºåºï¼Œåˆ©ç”¨å·²ç»å®šä¹‰å¥½çš„å¯¼æ•°è§„åˆ™ï¼Œç”Ÿæˆä¸€ä¸ªæ­£å¸¸è®¡ç®—ç¨‹åºå¯¹å¶çš„ç¨‹åºã€‚ä¸€èˆ¬æ¥è¯´æœ‰ä¸¤ç§è‡ªåŠ¨å¾®åˆ†æ–¹å¼ï¼Œä¸€ç§æ˜¯å‰å‘è‡ªåŠ¨å¾®åˆ†ï¼ˆForward Automatic Differentiationï¼‰å¦å¤–ä¸€ç§æ˜¯åå‘è‡ªåŠ¨å¾®åˆ†ï¼ˆReverse Automatic Differentiationï¼‰ï¼Œåè€…æ›´åŠ é€‚åˆå¤šå‚æ•°çš„æƒ…å†µï¼ˆç®—æ³•ç»†èŠ‚å°±ä¸è¯¦è¿°äº†ï¼Œå¤šå‚æ•°çš„æ—¶å€™åå‘è‡ªåŠ¨å¾®åˆ†çš„æ—¶é—´å¤æ‚åº¦æ›´ä½ï¼Œä¸€æ¬¡ä¼ æ’­å¯ä»¥è®¡ç®—æ‰€æœ‰çš„å‚æ•°ï¼‰ã€‚ åå‘è‡ªåŠ¨å¾®åˆ†ä¼šè®²æ‰€æœ‰çš„æ“ä½œä»¥ä¸€å¼ å›¾çš„æ–¹å¼å­˜å‚¨ä¸‹æ¥ï¼Œè¿™å¼ å›¾ç§°ä¸ºè®¡ç®—å›¾ã€‚è¿™ä¹Ÿæ˜¯å„å¤§æ·±åº¦å­¦ä¹ æ¡†æ¶çš„æ ¸å¿ƒæ‰€åœ¨â€”â€”å¦‚ä½•å¹²å‡€åœ°äº§ç”Ÿä¸€ä¸ªè®¡ç®—å›¾ï¼Œç„¶åé«˜æ•ˆè®¡ç®—å®ƒã€‚ ä¸ºäº†å±•ç¤ºè®¡ç®—å›¾æ˜¯ä»€ä¹ˆï¼Œæˆ‘ä»Cornellï¼ŒCS5740ï¼Œ2017spè¿™é—¨è¯¾çš„è¯¾ä»¶é‡Œæ¬è¿äº†ä¸€äº›å›¾ï¼Œç„¶åæŠŠä»–ä»¬åšæˆäº†åŠ¨ç”»ã€‚åŠ¨ç”»ä½¿ç”¨çº¯Juliaçš„æ¡†æ¶Luxoråˆ¶ä½œã€‚</p><p>æˆ‘ä»¬ä»¥è®¡ç®—ä¸‹é¢è¿™ä¸ªè¡¨è¾¾å¼ä¸ºä¾‹ï¼š</p><div>\[y = \mathbf{x}^T \mathbf{A} \mathbf{x} + \mathbf{b} \cdot \mathbf{x} + c\]</div><p>æˆ‘ä»¬å°†ä¼šè°ƒç”¨è¿™æ ·ä¸€äº›Juliaå‡½æ•°æ¥è®¡ç®—å®ƒï¼š</p><ol><li><span>$z_1 = x^T$</span></li><li><span>$z_2 = z_1 A$</span></li><li><span>$y_1 = z_2 x$</span></li><li><span>$y_2 = b \cdot x$</span></li><li><span>$y_1 + y_2 + c$</span></li></ol><p>è€Œå®é™…ä¸Šæˆ‘ä»¬å¯ä»¥æŠŠè¿™ä¸ªè¿‡ç¨‹ç”»æˆä¸‹é¢çš„è¿™ä¸ªå›¾</p><p><img src="http://blog.rogerluo.me/images/comput-graph-forward.gif" alt="forward"/></p><p>è€Œè®¡ç®—è¿™æ ·ä¸€å¼ å›¾ï¼Œæˆ‘ä»¬å°†å…ˆä»å¶å­ç»“ç‚¹å¼€å§‹èµ‹å€¼ï¼ˆç»¿è‰²ï¼‰ï¼Œç„¶åä¾æ¬¡è®¡ç®—ç›¸é‚»çš„èŠ‚ç‚¹ï¼Œä¸æ–­å‘å‰ä¼ æ’­ã€‚è¿™ä¸ªè¿‡ç¨‹ç§°ä¸ºå‰å‘ä¼ æ’­è¿‡ç¨‹ã€‚ æ¥ä¸‹æ¥æˆ‘ä»¬æŒ‰ç…§é“¾å¼æ³•åˆ™æ¥è®¡ç®—å¯¼æ•°ï¼Œæ¯ä¸ªèŠ‚ç‚¹è¿”å›çš„å¯¼æ•°éƒ½å’Œè¾“å…¥çš„æ•°é‡ç›¸åŒï¼Œæˆ‘ä»¬ä»æœ€ä¸Šé¢çš„èŠ‚ç‚¹å¼€å§‹å‘åä¼ æ’­ï¼Œå°†å½“å‰æœ‰å¯¼æ•°çš„èŠ‚ç‚¹æ ‡è®°ä¸ºçº¢è‰²ã€‚</p><p><img src="http://blog.rogerluo.me/images/comput-graph-backward.gif" alt="backward"/></p><p>å½“çº¢è‰²ä¼ æ’­åˆ°å˜é‡å¤„æ—¶ï¼Œæˆ‘ä»¬å°±è·å¾—äº†å˜é‡çš„å¯¼æ•°ã€‚</p><h2 id="åŠ¨æ€å›¾-VS-é™æ€å›¾-1"><a class="docs-heading-anchor" href="#åŠ¨æ€å›¾-VS-é™æ€å›¾-1">åŠ¨æ€å›¾ VS é™æ€å›¾</a><a class="docs-heading-anchor-permalink" href="#åŠ¨æ€å›¾-VS-é™æ€å›¾-1" title="Permalink"></a></h2><p>æŒ‰ç…§æ„å»ºè®¡ç®—å›¾çš„æ–¹å¼ä¸åŒï¼Œæˆ‘ä»¬å¯ä»¥å°†è®¡ç®—å›¾åˆ†ä¸ºåŠ¨æ€å›¾å’Œé™æ€å›¾ä¸¤ç§ï¼Œå°½ç®¡åœ¨ç®—æ³•ä¸Šå¹¶æ²¡æœ‰å¾ˆå¤§åŒºåˆ«ï¼Œä½†æ˜¯åœ¨å®ç°ä¸Šæˆ‘ä»¬å¯ä»¥é€‰æ‹©åœ¨å‰å‘ä¼ æ’­çš„è¿‡ç¨‹ä¸­æ„å»ºè®¡ç®—å›¾ï¼ˆæ¯”å¦‚PyTorchï¼‰ï¼Œä¹Ÿå¯ä»¥é€‰æ‹©å…ˆæ„å»ºè®¡ç®—å›¾å†è®¡ç®—å„ä¸ªèŠ‚ç‚¹çš„å€¼ï¼ˆæ¯”å¦‚tensorflowï¼‰ã€‚</p><p>å°±æˆ‘ä¸ªäººè€Œè¨€ï¼Œæˆ‘æ¯”è¾ƒå–œæ¬¢PyTorchï¼Œæ‰€ä»¥è¿™é‡Œæˆ‘å°†å®ç°ä¸€ä¸ªåŠ¨æ€å›¾ã€‚</p><p>å®šä¹‰è®¡ç®—å›¾ä¸­çš„èŠ‚ç‚¹ åœ¨æˆ‘ä»¬å¼€å§‹å†™å…·ä½“çš„å®ç°ä¹‹å‰ï¼Œå…ˆæ¥ä¸ºæ‰€æœ‰çš„èŠ‚ç‚¹ç±»å‹å®šä¹‰ä¸€ä¸ªæŠ½è±¡ç±»å‹ï¼ˆç±»ä¼¼äºåŸºç±»ï¼‰ï¼š</p><pre><code class="language-julia">abstract type AbstractNode end</code></pre><p>åœ¨PyTorché‡Œï¼Œèƒ½å¤Ÿæ‹¥æœ‰å¯¼æ•°çš„ç§°ä¸ºå˜é‡ï¼ˆVariableï¼‰ï¼Œå°½ç®¡åœ¨0.4ç‰ˆæœ¬ä¹‹åTensoré»˜è®¤å°±æ˜¯ä¸€ä¸ªVariableäº†ï¼ˆæœ‰requires_gradä¸ºTrueï¼‰ï¼Œåœ¨åç«¯ä¾ç„¶è¿˜æœ‰è¿™ä¸ªç±»å‹ã€‚å®ƒæ˜¯å¯¹è®¡ç®—å›¾æ„å»ºè¿‡ç¨‹ä¸­ä¸å¯æˆ–ç¼ºçš„ç±»å‹ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬æ¥å®šä¹‰å˜é‡ï¼ˆVariableï¼‰</p><pre><code class="language-julia">mutable struct Variable{T} &lt;: AbstractNode
    value::T
    grad::T

    Variable(val::T) where T = new{T}(val, zero(grad))
end</code></pre><p>ç±»ä¼¼PyTorchä¸€æ ·ï¼Œå˜é‡å­˜å‚¨äº†å€¼ï¼ˆvalueï¼‰å’Œå®ƒçš„æ¢¯åº¦ï¼ˆgradï¼‰ï¼Œåœ¨æ¯ä¸€æ¬¡åå‘ä¼ æ’­çš„è¿‡ç¨‹ä¸­æˆ‘ä»¬å°†ä¼šä¸æ–­åœ°å°†æ¢¯åº¦ç´¯åŠ åˆ°è¿™ä¸ªå˜é‡çš„æ¢¯åº¦ä¸Šå»ã€‚è¿™é‡Œ <code>zero</code> æ˜¯å‡ ä¹æ‰€æœ‰Juliaæ•°å€¼ç±»å‹éƒ½æœ‰çš„ä¸€ä¸ªæ¥å£ï¼Œå®ƒå°†æ”¾å›å¯¹åº”çš„é›¶å…ƒç´ ï¼Œä¾‹å¦‚å¯¹ <code>Float64</code> ç±»å‹çš„Juliaå˜é‡ï¼Œå°†è¿”å›0.0ï¼Œå¯¹<code>Array{Float64}</code>å°†è¿”å›ä¸€ä¸ªå……æ»¡0.0çš„ <code>Array{Float64}</code>ã€‚</p><h2 id="å…¶å®ƒèŠ‚ç‚¹-1"><a class="docs-heading-anchor" href="#å…¶å®ƒèŠ‚ç‚¹-1">å…¶å®ƒèŠ‚ç‚¹</a><a class="docs-heading-anchor-permalink" href="#å…¶å®ƒèŠ‚ç‚¹-1" title="Permalink"></a></h2><p>æˆ‘ä»¬ç°åœ¨æœ‰äº†å˜é‡äº†ï¼Œä¹Ÿå°±æ˜¯è®¡ç®—å›¾çš„å¶å­ç»“ç‚¹ï¼Œæ¥ä¸‹æ¥è¿˜éœ€è¦æœ‰ä¸­é—´çš„èŠ‚ç‚¹ã€‚å®ƒä»¬å°†å­˜å‚¨ä¸€ä¸ªå‡½æ•°å’Œå®ƒä»¬çš„è¾“å…¥</p><pre><code class="language-julia">struct Node{FT &lt;: Function, ArgsT &lt;: Tuple, KwargsT &lt;: NamedTuple} &lt;: AbstractNode
    f::FT
    args::ArgsT
    kwargs::KwargsT
end</code></pre><p>æˆ‘ä»¬è¿™é‡Œä½¿ç”¨å‚æ•°ç±»å‹ï¼Œè¿™æ ·åœ¨å°†æ¥è¿›è¡Œåˆ†å‘çš„æ—¶å€™ï¼Œç¼–è¯‘å™¨èƒ½å¤Ÿè‡ªå·±é€šè¿‡ç±»å‹æ¨å¯¼å‡ºè¦åˆ†å‘çš„å‡½æ•°ä»è€Œæé«˜è¿è¡Œæ—¶çš„æ€§èƒ½ã€‚ ä½†æˆ‘ä»¬åº”å½“è¦è€ƒè™‘broadcastï¼ˆå¹¿æ’­ï¼‰å’Œæ­£å¸¸çš„å‡½æ•°è°ƒç”¨çš„åŒºåˆ«ï¼Œç”±äºJuliaèƒ½å¤Ÿå¯¹ä»»æ„å‡½æ•°è¿›è¡Œå¹¿æ’­ï¼Œå¹¿æ’­æ—¶æ‰€è°ƒç”¨çš„å®é™…ä¸Šæ˜¯ broadcast å‡½æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸å¦¨å®ç°ä¸¤ä¸ªtraitæ¥åŒºåˆ†è¿™ç§æƒ…å†µï¼š</p><pre><code class="language-julia">abstract type Operator end

module Trait
import YAAD: Operator

struct Method{FT} &lt;: Operator
    f::FT
end

struct Broadcasted{FT} &lt;: Operator
    f::FT
end
end # Trait</code></pre><p>è¿™é‡Œæˆ‘å°†è¿™ä¸¤ä¸ªtraitå®ç°åœ¨ä¸€ä¸ªmoduleé‡Œé¢æ˜¯ä¸ºäº†èƒ½å¤Ÿæ˜¾ç¤ºåœ°ä½“ç°å‡ºä»–ä»¬ä¿©æ˜¯traitï¼Œå› ä¸ºä¹‹åè°ƒç”¨çš„æ—¶å€™å°†ä¼šå†™ä¸º <code>Trait.Method</code> å’Œ <code>Trait.Broadcasted</code> ï¼Œä»–ä»¬å„è‡ªå­˜å‚¨äº†ä¸€ä¸ªå‡½æ•°ï¼ˆæ³¨æ„Juliaé‡Œæ¯ä¸ªå‡½æ•°éƒ½æ˜¯ä¸€ä¸ªcallableçš„ç±»å‹ï¼‰ã€‚ ç„¶åæˆ‘ä»¬æŠŠåŸå…ˆNodeç±»å‹çš„å‚æ•°çº¦æŸFunctionæ”¹æˆOperator</p><pre><code class="language-julia">struct Node{FT &lt;: Operator, ArgsT &lt;: Tuple, KwargsT &lt;: NamedTuple} &lt;: AbstractNode
    f::FT
    args::ArgsT
    kwargs::KwargsT
end</code></pre><p>æ¥ä¸‹æ¥ä¸ºäº†æ–¹ä¾¿æˆ‘ä»¬æ¥å®šä¹‰ä¸€äº›æ„é€ å‡½æ•°</p><pre><code class="language-julia"># wrap function to Method
Node(f::Function, args, kwargs) = Node(Trait.Method(f), args, kwargs)
Node(op, args) = Node(op, args, NamedTuple())</code></pre><p>ç¬¬ä¸€ä¸ªæ˜¯å› ä¸ºå¤§éƒ¨åˆ†æ—¶é—´ï¼Œæˆ‘ä»¬è¦è®°å½•çš„å‡½æ•°å°±æ˜¯å®ƒæœ¬èº«è€Œä¸æ˜¯ä¸€ä¸ªå¹¿æ’­ï¼Œç¬¬äºŒä¸ªæ˜¯å› ä¸ºå¤§éƒ¨åˆ†æ¶‰åŠæ•°å€¼è®¡ç®—çš„å‡½æ•°éƒ½æ²¡æœ‰å…³é”®å­—ï¼ˆkeywordï¼‰ã€‚ å®é™…ä¸Šï¼ŒNodeç±»å‹æœ¬èº«ä¹Ÿåªæ˜¯å‡½æ•°å’Œå®ƒçš„è¾“å…¥ç±»å‹çš„ä¸€ä¸ªtraitï¼Œå®ƒåœ¨è®¡ç®—çš„è¿‡ç¨‹ä¸­ä¹Ÿåªæ˜¯è´Ÿè´£ï¼ˆé™æ€åœ°ï¼‰åˆ†å‘æ–¹æ³•ã€‚åœ¨æ›´åŠ é«˜çº§çš„å®ç°é‡Œï¼Œæˆ‘ä»¬å®é™…ä¸Šæœ‰æ›´åŠ æ¼‚äº®çš„å®ç°ï¼Œåˆ©ç”¨Cassette.jlå¯¹Juliaä»£ç è¿›è¡Œéä¾µå…¥å¼åœ°è‡ªåŠ¨å¾®åˆ†ï¼ˆæ„æ€æ˜¯æ— éœ€ç»™æºç é‡è½½è¿ç®—ç¬¦ï¼Œå¢åŠ Variableç±»å‹ï¼Œç¼–è¯‘å™¨å°†ç›´æ¥åœ¨JITæœŸé—´å¯¹å‰å‘ä¼ æ’­çš„ä»£ç è¿›è¡Œå˜æ¢ï¼Œä»è€Œç›´æ¥å¾—åˆ°è®¡ç®—æ¢¯åº¦çš„ä»£ç ï¼‰ã€‚ æœ€åï¼Œæˆ‘ä»¬è¿˜éœ€è¦å®šä¹‰ä¸€ä¸ªç¼“å­˜å‡½æ•°è¾“å‡ºçš„å¯¹è±¡ï¼Œè¿™ä¸ªç¼“å­˜çš„å€¼å°†ä¼šè¢«ä¸€äº›å‡½æ•°çš„å¯¼æ•°ç”¨åˆ°</p><pre><code class="language-julia">mutable struct CachedNode{NT &lt;: AbstractNode, OutT} &lt;: AbstractNode
    node::NT
    output::OutT
end</code></pre><p>è€Œè¿™ä¸ªèŠ‚ç‚¹å°†åœ¨å‰å‘ä¼ æ’­çš„åŒæ—¶è¢«æ„å»ºå‡ºæ¥ï¼ˆå¦åˆ™æˆ‘ä»¬æ— æ³•çŸ¥é“è¾“å‡ºçš„ç±»å‹æ˜¯ä»€ä¹ˆï¼‰</p><pre><code class="language-julia">function CachedNode(f, args...; kwargs...)
    node = Node(f, args, kwargs.data) # this constructs a Node
    output = forward(node)
    CachedNode(node, output)
end</code></pre><p>æˆ‘ä»¬æš‚ä¸”æŠŠè¿™ä¸ªæ¥å£å®šä¹‰ä¸ºforwardï¼ˆä¸PyTorchä¸€è‡´ï¼‰</p><h2 id="æ±‚å€¼-1"><a class="docs-heading-anchor" href="#æ±‚å€¼-1">æ±‚å€¼</a><a class="docs-heading-anchor-permalink" href="#æ±‚å€¼-1" title="Permalink"></a></h2><p>æ±‚å€¼æ˜¯æœ€é‡è¦çš„éƒ¨åˆ†ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦å°†æˆ‘ä»¬çš„è‡ªåŠ¨å¾®åˆ†è®¾è®¡åœ°å¯æ‰©å±•ï¼Œå°½é‡ä¸è¦åœ¨æ‰©å±•çš„æ—¶å€™ç¼–å†™å†—ä½™çš„ä»£ç ã€‚è€Œåœ¨Juliaé‡Œï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨å¤šé‡æ´¾å‘ï¼ˆmultiple dispatchï¼‰å®ç°è¿™ä¸€ç‚¹ã€‚</p><p>æ±‚å€¼æ˜¯æœ€é‡è¦çš„éƒ¨åˆ†ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦å°†æˆ‘ä»¬çš„è‡ªåŠ¨å¾®åˆ†è®¾è®¡åœ°å¯æ‰©å±•ï¼Œå°½é‡ä¸è¦åœ¨æ‰©å±•çš„æ—¶å€™ç¼–å†™å†—ä½™çš„ä»£ç ã€‚è€Œåœ¨Juliaé‡Œï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨å¤šé‡æ´¾å‘ï¼ˆmultiple dispatchï¼‰å®ç°è¿™ä¸€ç‚¹ã€‚</p><h3 id="å‰å‘ä¼ æ’­-1"><a class="docs-heading-anchor" href="#å‰å‘ä¼ æ’­-1">å‰å‘ä¼ æ’­</a><a class="docs-heading-anchor-permalink" href="#å‰å‘ä¼ æ’­-1" title="Permalink"></a></h3><p>é‚£ä¹ˆå¦‚ä½•è¿›è¡Œå‰å‘ä¼ æ’­å‘¢ï¼Ÿè¿™å–å†³äºå¯¹äº forward è¿™ä¸ªæŠ½è±¡å‡½æ•°ï¼ˆgeneric functionï¼‰ï¼Œå®ç°äº†ä»€ä¹ˆæ–¹æ³•ï¼ˆmethodï¼‰ï¼š</p><ol><li>å¦‚æœè¾“å…¥æ˜¯ä¸€ä¸ª Node ç±»å‹ï¼Œæˆ‘ä»¬å°†å…¶å±•å¼€</li></ol><pre><code class="language-julia">forward(node.f, map(forward, node.args)...; map(forward, node.kwargs)...)</code></pre><ol><li>è¿™å°†ä½¿å¾—æˆ‘ä»¬å¤šäº†ä¸€å±‚æ’å…¥è‡ªå®šä¹‰æ–¹æ³•çš„æ¥å£ï¼Œå¦‚æœæˆ‘ä»¬æœ‰ä¸€ä¸ªè‡ªå®šä¹‰çš„ç®—ç¬¦ï¼Œå®ƒå¹¶éä¸€ä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬åªéœ€è¦å®ç°å¯¹åº”çš„æ–¹æ³•å³å¯ï¼Œä¾‹å¦‚</li></ol><pre><code class="language-julia">struct Linear &lt;: Operator
  w::Matrix{Float64}
  b::Vector{Float64}
end


forward(op::Linear, x::Vector{Float64}) = op.w * x + b</code></pre><ol><li>ç„¶è€Œå¯¹äºç®€å•çš„å‡½æ•°è°ƒç”¨ï¼Œæˆ‘ä»¬å¹¶ä¸æƒ³æ¯æ¬¡éƒ½å†™</li></ol><pre><code class="language-julia">function forward(::Method{typeof(sin)}, x)
  sin(x)
end</code></pre><p>æ‰€ä»¥æˆ‘ä»¬å†å®ç°ä¸€ä¸ªé»˜è®¤å±•å¼€Operatorçš„æ–¹æ³•</p><pre><code class="language-julia">forward(op::Operator, args...; kwargs...) = op(args...; kwargs...)</code></pre><p>è¿™æ„å‘³ç€åªè¦Operatorå®ç°äº†è‡ªå·±çš„callæ–¹æ³•ï¼ˆå¦‚æœè¿™ä¸ªOperatorç±»å‹æ˜¯callableçš„ï¼‰ï¼Œé‚£ä¹ˆå°±æ— éœ€å»å†™åˆ«çš„ä¸œè¥¿ï¼Œè‡ªåŠ¨è°ƒç”¨è¿™ä¸ªæ–¹æ³•ã€‚å½“ç„¶æˆ‘ä»¬ç°åœ¨è¦å›å»ç»™Method Traitå®ç°ä¸€ä¸‹å®ƒçš„callæ–¹æ³•</p><pre><code class="language-julia">(op::Trait.Method)(args...; kwargs...) = op.f(args...; kwargs...)</code></pre><p>ä¾‹å¦‚ï¼Œæˆ‘ä»¬ç°åœ¨åªéœ€è¦å®šä¹‰ Linearçš„callæ–¹æ³•å°±å¤Ÿäº†</p><pre><code class="language-julia">(op::Linear)(x::Vector) = op.w * x + op.b</code></pre><ol><li>æ­¤å¤–ï¼Œé™¤äº†å˜é‡ï¼Œè¿˜æœ‰ä¸€äº›å¸¸æ•°ä¾‹å¦‚</li></ol><pre><code class="language-julia">Variable(2.0) + 3.0</code></pre><p>è¿™é‡Œçš„3.0å°±æ˜¯ä¸€ä¸ªä¸éœ€è¦æ±‚å¯¼çš„å¸¸æ•°ï¼Œæˆ‘ä»¬åŸå°ä¸åŠ¨åœ°è¿”å›å®ƒï¼Œè¿™æ ·æˆ‘ä»¬åªè¦å®ç°ä¸€ä¸ª value æ¥å£æ¥è·å–å€¼å³å¯</p><pre><code class="language-julia">value(x) = x
value(x::Variable) = x.value
value(x::CachedNode) = x.output</code></pre><p>ç„¶åç›´æ¥è°ƒç”¨value</p><pre><code class="language-julia">forward(x) = x
forward(x::Variable) = value(x)</code></pre><p>ç„¶ååˆ«å¿˜äº†ï¼Œå¯¹äºå…¶å®ƒç±»å‹æˆ‘ä»¬è¿”å›ä¸€ä¸ªå‹å¥½ä¸€äº›çš„æŠ¥é”™</p><pre><code class="language-julia">forward(x::NT) where {NT &lt;: AbstractNode} = error(&quot;forward method is not implemented for node type: $NT&quot;)

function value(x::T) where {T &lt;: AbstractNode}
    error(
        &quot;Expected value in this node $x of type $T &quot;,
        &quot;check if you defined a non-cached node&quot;,
        &quot; or overload value function for your node.&quot;
    )
end</code></pre><p>ç„¶åå¯¹äº <code>Variable</code> å’Œ <code>CachedNode</code> æˆ‘ä»¬è¦è¿”å›å®ƒä»¬å­˜å‚¨çš„å€¼ï¼Œå¥½çš„ğŸ‘Œï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»æå®šå‰å‘ä¼ æ’­éƒ¨åˆ†äº†ï¼Œæ¥ä¸‹æ¥æ˜¯åå‘ä¼ æ’­éƒ¨åˆ†ã€‚</p><h2 id="åå‘ä¼ æ’­-1"><a class="docs-heading-anchor" href="#åå‘ä¼ æ’­-1">åå‘ä¼ æ’­</a><a class="docs-heading-anchor-permalink" href="#åå‘ä¼ æ’­-1" title="Permalink"></a></h2><p>åå‘ä¼ æ’­å®é™…ä¸Šå’Œå‰å‘ä¼ æ’­å‡ ä¹æ˜¯ä¸€æ ·çš„ï¼Œæˆ‘ä»¬åªè¦ä¸æ–­åœ°åœ¨ä¸åŒçš„ç±»å‹æ ‡ç­¾ä¸‹è¿­ä»£backwardæ¥å£å³å¯ï¼ˆæ³¨æ„æˆ‘ä¸æ‰“ç®—åœ¨è¿™é‡Œå®ç°å…³é”®è¯çš„åå‘ä¼ æ’­ï¼Œå°½ç®¡è¿™å¹¶ä¸éš¾ï¼‰</p><p>é¦–å…ˆï¼Œå¯¹Variableæ¥è¯´ï¼Œè¿™å¾ˆç®€å•ç›´æ¥åŠ æ¥æ”¶åˆ°çš„æ¢¯åº¦å°±å¥½äº†</p><pre><code class="language-julia">function backward(x::Variable, grad)
    x.grad += grad
    nothing
end</code></pre><p>ç„¶åæˆ‘ä»¬ç°åœ¨å®šä¹‰ <code>CachedNode</code> çš„åå‘ä¼ æ’­è§„åˆ™ æˆ‘ä»¬å…ˆä»ä¸€ä¸ªå« <code>gradient</code> çš„æ–¹æ³•é‡Œè·å¾—å„ä¸ªè¾“å…¥çš„å¯¼æ•° ç„¶åå†æŠŠè¿™äº›å¯¼æ•°ä¾æ¬¡è¾“å…¥åˆ°è¾“å…¥ç±»å‹å¯¹åº”çš„ <code>backward</code> å‡½æ•°é‡Œå»</p><pre><code class="language-julia">function backward(node::CachedNode, f, grad)
    grad_inputs = gradient(node, grad)
    for (each, each_grad) in zip(args(node), grad_inputs)
        backward(each, each_grad)
    end
    nothing
end</code></pre><p>ç­‰ç­‰ï¼Œæˆ‘ä»¬è¦åœ¨è¿™é‡ŒåŠ ä¸€äº›å‹å¥½çš„æŠ¥é”™ä¿¡æ¯ï¼Œé¢å¾—ä»¥åæˆ‘ä»¬è‡ªå·±æŠ“ç‹‚ã€‚é¦–å…ˆæ˜¯ç±»å‹çš„æ£€æŸ¥ï¼Œè¿™å®Œå…¨æ˜¯é™æ€çš„ï¼Œæ‰€ä»¥ä¸åŒæ‹…å¿ƒä¼šå½±å“æ€§èƒ½</p><pre><code class="language-julia">backward_type_assert(node::CachedNode{&lt;:AbstractNode, T}, grad::T) where T = true
backward_type_assert(node::CachedNode{&lt;:AbstractNode, T1}, grad::T2) where {T1, T2} =
    error(&quot;Gradient is expected to have the same&quot;,
          &quot; type with outputs, expected $T1&quot;,
          &quot; got $T2&quot;)</code></pre><p>æˆ‘ä»¬åœ¨è¿™é‡Œè¦æ±‚è¾“å‡ºå’Œæ¢¯åº¦çš„ç±»å‹è¦ä¸€æ ·ï¼Œä½†æ˜¯å¯¹äºå¤šç»´æ•°ç»„ï¼ˆ<code>AbstractArray</code>ï¼‰æˆ‘ä»¬åªè¦æ±‚å®ƒä»¬çš„æ•°æ®ç±»å‹å’Œç»´åº¦ç›¸åŒå³å¯ï¼Œå› ä¸ºæœ‰å¯èƒ½ä¸€äº›å‡½æ•°ä¼šè¿”å›ç‰¹åˆ«ä¼˜åŒ–çš„æ•°ç»„ï¼ˆä¾‹å¦‚ç¨€ç–æ•°ç»„ï¼Œæˆ–è€…ä¸€äº›æ‡’æƒ°æ±‚å€¼çš„ä¸­é—´ç»“æœï¼‰ã€‚</p><pre><code class="language-julia"># exclude arrays
backward_type_assert(node::CachedNode{&lt;:AbstractNode, T1}, grad::T2) where
    {T, N, T1 &lt;: AbstractArray{T, N}, T2 &lt;: AbstractArray{T, N}} = true
ç„¶åæˆ‘ä»¬è¿˜è¦æ£€æŸ¥æ¢¯åº¦å’Œè¾“å‡ºçš„å¤§å°æ˜¯å¦åŒ¹é…
function backward_size_assert(node::CachedNode, grad)
    size(node.output) == size(grad) ||
        error(
            &quot;gradient should have the same size with output,&quot;,
            &quot; expect size $(size(node.output)), got $(size(grad))&quot;
        )
end</code></pre><p>åœ¨Juliaé‡Œï¼Œå¯ä»¥é€šè¿‡ç¼–è¯‘é€‰é¡¹æŠŠè¾¹ç•Œæ£€æŸ¥å…³æ‰ï¼Œå› ä¸ºæˆ‘ä»¬æœ‰æ—¶å€™å®Œå…¨ä¸éœ€è¦è¾¹ç•Œæ£€æŸ¥ï¼Œä½ å¯ä»¥é€šè¿‡å¢åŠ  @boundscheck è¿™ä¸ªå®æ¥å®ç°è¿™ä¸€ç‚¹ï¼Œæœ€åæˆ‘ä»¬çš„backwardå‡½æ•°å¦‚ä¸‹ï¼š</p><pre><code class="language-julia">function backward(node::CachedNode, f, grad)
    backward_type_assert(node, grad)
    @boundscheck backward_size_assert(node, grad)

    grad_inputs = gradient(node, grad)
    for (each, each_grad) in zip(args(node), grad_inputs)
        backward(each, each_grad)
    end
    nothing
end</code></pre><p>ç°åœ¨æˆ‘ä»¬æ¥è€ƒè™‘å¦‚ä½•å®šä¹‰æ¢¯åº¦ï¼Œä¹Ÿå°±æ˜¯gradientæ–¹æ³•ï¼Œæˆ‘ä»¬ä¾ç„¶å¸Œæœ›ä¸è¦å†™å†—ä½™çš„ä»£ç ï¼ŒåŒæ—¶ä¿è¯æ€§èƒ½å’Œæ‰©å±•æ€§ã€‚æ¯”å¦‚ï¼Œå®ç°sinçš„å¯¼æ•°åªéœ€è¦å®šä¹‰</p><pre><code class="language-julia">gradient(::typeof(sin), grad, output, x) = grad * cos(x)</code></pre><p>æˆ‘ä»¬è¿˜æ˜¯åˆ©ç”¨å¤šé‡æ´¾å‘æ¥å®ç°è¿™ä¸€ç‚¹ï¼Œå…ˆæŠŠ <code>CachedNode</code> å±•å¼€</p><pre><code class="language-julia">gradient(x::CachedNode, grad) = gradient(x.node.f, grad, x.output, map(value, x.node.args)...; map(value, x.node.kwargs)...)</code></pre><p>ç„¶åæŠŠOperatorå±•å¼€åˆ°å‡½æ•°ä¸Šå»</p><pre><code class="language-julia">gradient(x::Trait.Method, grad, output, args...; kwargs...) =
    gradient(x.f, grad, output, args...; kwargs...)</code></pre><p>æœ€åå®šä¹‰ä¸€ä¸ªæŠ¥é”™ä¿¡æ¯</p><pre><code class="language-julia">gradient(fn, grad, output, args...; kwargs...) =
    error(
        &quot;gradient of operator $fn is not defined\n&quot;,
        &quot;Possible Fix:\n&quot;,
        &quot;define one of the following:\n&quot;,
        &quot;1. gradient(::typeof($fn), grad, output, args...; kwargs...)\n&quot;,
        &quot;2. gradient(op::Trait.Method{typeof($fn)}, grad, output, args...; kwargs...)\n&quot;,
        &quot;3. gradient(op::Trait.Broadcasted{typeof($fn)}, grad, output, args...; kwargs...)\n&quot;
    )</code></pre><p>è¿™æ ·ï¼Œæˆ‘ä»¬å°±å¯ä»¥é€‰æ‹©ä¸åŒçš„gradientæ¥å£æ¥å®ç°å¯¼æ•°ï¼ŒJuliaå°†è‡ªåŠ¨æ´¾å‘ä½ å®ç°çš„è¿™ä¸ªæ–¹æ³•ï¼Œä¾‹å¦‚</p><pre><code class="language-julia"># I re-define the concrete type `Linear` here in order to store the gradient
struct Linear &lt;: Operator
  w::Variable{Matrix{Float64}}
  b::Variable{Vector{Float64}}
end

function gradient(op::Linear, grad, output, x)
  grad_w, grad_b = # some gradient expression to calculate the gradient of w and b
  backward(op.w, grad_w) # update gradient of w
  backward(op.w, grad_b) # update gradient of b

  grad_input = # calculate the gradient of input
  grad_input # return the gradient of input
end</code></pre><p>æœ€åæˆ‘ä»¬å®šä¹‰ä¸€ä¸ª <code>register</code> çš„æ¥å£ç”¨æ¥äº§ç”Ÿ <code>CachedNode</code></p><pre><code class="language-julia">register(f, args...; kwargs...) = CachedNode(f, args...; kwargs...)</code></pre><p>è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥é€šè¿‡é‡è½½å‡½æ•°/è¿ç®—ç¬¦æ¥æ„å»ºè®¡ç®—å›¾äº†</p><pre><code class="language-julia">Base.sin(x::AbstractNode) = register(Base.sin, x)
gradient(::typeof(Base.sin), grad, output, x) = (grad * cos(x), )</code></pre><p>ä¸è¿‡ç­‰ç­‰ï¼Œä¼¼ä¹è¿™é‡Œæœ‰æ—¶å€™éœ€è¦åˆ¤æ–­ä¸€ä¸‹è¾“å…¥æ˜¯ä»€ä¹ˆç±»å‹æ¯”è¾ƒå¥½ï¼Œæˆ‘ä»¬ä¸å¦¨ä¸ºVariableå’ŒCachedNodeå®šä¹‰ä¸€ä¸ªæŠ½è±¡ç±»å‹Value</p><pre><code class="language-julia">abstract type Value{T} &lt;: AbstractNode end</code></pre><p>Valueç±»å‹å°†å¸¦æœ‰å…¶å­ç±»å‹çš„å€¼çš„ç±»å‹Tä½œä¸ºå…¶å‚æ•°ã€‚ç°åœ¨å…ˆå›å»ä¿®æ”¹ <code>Variable</code> å’Œ <code>CachedNode</code></p><pre><code class="language-julia">mutable struct Variable{T} &lt;: Value{T}
    value::T
    grad::T

    Variable(val::T) where T = new{T}(val, zero(grad))
end

mutable struct CachedNode{NT &lt;: AbstractNode, OutT} &lt;: Value{OutT}
    node::NT
    output::OutT
end</code></pre><h3 id="å¹¿æ’­-1"><a class="docs-heading-anchor" href="#å¹¿æ’­-1">å¹¿æ’­</a><a class="docs-heading-anchor-permalink" href="#å¹¿æ’­-1" title="Permalink"></a></h3><p>ç„¶è€Œä¸Šé¢çš„å®šä¹‰è¿˜åªèƒ½ç»™æ ‡é‡ç”¨ï¼Œå¯¹äºæ•°ç»„æˆ‘ä»¬è¿˜éœ€è¦å¹¿æ’­æ‰è¡Œã€‚Juliaè‡ªå·±å®ç°äº†ä¸€å¥—å¹¿æ’­ç³»ç»Ÿï¼Œå®ƒèƒ½å¤Ÿå¹¿æ’­ä»»ä½•Juliaå‡½æ•°åˆ°æ•°ç»„ä¸Šï¼Œä¼šèåˆå¤šä¸ªè¢«å¹¿æ’­çš„å‡½æ•°ï¼ˆä»è€Œäº§ç”Ÿæ›´ä¼˜è´¨çš„å‘é‡åŒ–SIMDä»£ç ï¼‰ï¼ŒåŒæ—¶è¿˜å…è®¸å®šä¹‰å¹¿æ’­çš„è¡Œä¸ºã€‚è¿™æ°å¥½å°±æ˜¯æˆ‘ä»¬éœ€è¦çš„ï¼šæˆ‘ä»¬è¦åœ¨å¹¿æ’­çš„åŒæ—¶äº§ç”Ÿä¸€ä¸ªè®¡ç®—å›¾ï¼Œè®°å½•è¿™ä¸ªæ“ä½œ é¦–å…ˆæˆ‘ä»¬å®šä¹‰æˆ‘ä»¬è‡ªå·±çš„å¹¿æ’­é£æ ¼ï¼ˆBroadcastStyleï¼‰ï¼š</p><pre><code class="language-julia">struct ComputGraphStyle &lt;: Broadcast.BroadcastStyle end
Base.BroadcastStyle(::Type{&lt;:AbstractNode}) = ComputGraphStyle()
Broadcast.BroadcastStyle(s::ComputGraphStyle, x::Broadcast.BroadcastStyle) = s</code></pre><p>è¿™è¿˜ä¸å¤Ÿï¼ŒJuliaçš„broadcastæ˜¯æ‡’æƒ°æ±‚å€¼çš„ï¼Œå®ƒå…ˆé€šè¿‡broadcastedæ–¹æ³•æ„å»ºä¸­é—´ç±»å‹ï¼Œç„¶åå†åœ¨æœ€åé€šè¿‡materializeæ–¹æ³•è¿›è¡Œæ±‚å€¼ã€‚æˆ‘ä»¬è¿˜éœ€è¦è®©å®ƒä»¬ä¹Ÿè¢«è®°å½•åœ¨è®¡ç®—å›¾é‡Œ</p><pre><code class="language-julia">function Broadcast.broadcasted(::ComputGraphStyle, f, args...)
    mt = Trait.Broadcasted(f)
    register(mt, args...)
end

Broadcast.materialize(x::AbstractNode) = register(Broadcast.materialize, x)</code></pre><p>ç„¶åæˆ‘ä»¬è®© <code>materialize</code> åœ¨åå‘ä¼ æ’­çš„æ—¶å€™ç›´æ¥è¿”å›æ¢¯åº¦</p><pre><code class="language-julia">function backward(node::CachedNode, ::typeof(Broadcast.materialize), grad)
    backward_type_assert(node, grad)
    @boundscheck backward_size_assert(node, grad)
    backward(node.node.args[1], grad) # materialize only has one arguments, we don&#39;t need the for loop
end</code></pre><p>ç„¶è€Œè¿™æ—¶ï¼ŒBroadcastedç±»å‹çš„backwardä¼šè°ƒç”¨é»˜è®¤çš„CachedNodeçš„backwardæ–¹æ³•ï¼Œæœ‰æ—¶å°±ä¼šå› ä¸ºç±»å‹ä¸åŒæŠ¥é”™ï¼ˆå› ä¸ºæˆ‘ä»¬ä¹‹å‰è¿™ä¹ˆå®šä¹‰äº†ï¼‰æˆ‘ä»¬ä¸ºè¿™ä¸ªç±»å‹å¼€ä¸ªåé—¨</p><pre><code class="language-julia">function backward(node::CachedNode, ::Trait.Broadcasted, grad)
    grad_inputs = gradient(node, grad)
    for (each, each_grad) in zip(args(node), grad_inputs)
        backward(each, each_grad)
    end
    nothing
end</code></pre><h3 id="å…è´¹è·å¾—æ›´å¤šçš„ç®—ç¬¦-1"><a class="docs-heading-anchor" href="#å…è´¹è·å¾—æ›´å¤šçš„ç®—ç¬¦-1">å…è´¹è·å¾—æ›´å¤šçš„ç®—ç¬¦</a><a class="docs-heading-anchor-permalink" href="#å…è´¹è·å¾—æ›´å¤šçš„ç®—ç¬¦-1" title="Permalink"></a></h3><p>Juliaæœ‰ä¸€ä¸ªåŒ…å«åš DiffRules.jl å®ƒè®°å½•äº†å¤§é‡å¸¸ç”¨ç®—ç¬¦çš„å¯¼æ•°è§„åˆ™ï¼Œå¹¶ä¸”è¿™äº›å¯¼æ•°è§„åˆ™éƒ½ä»¥Juliaè¡¨è¾¾å¼çš„æ–¹å¼è®°å½•ï¼Œè¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥åˆ©ç”¨å…ƒç¼–ç¨‹æ‰¹é‡ç”Ÿäº§ç®—ç¬¦ã€‚ è¿™äº›å¯¼æ•°è§„åˆ™éƒ½åœ¨ä¸€ä¸ªå¸¸æ•°åˆ—è¡¨é‡Œï¼Œåä¸º<code>DiffRules.DEFINED_DIFFRULES</code>ï¼Œæˆ‘ä»¬éå†å®ƒå³å¯</p><pre><code class="language-julia">for (mod, name, nargs) in keys(DiffRules.DEFINED_DIFFRULES)
  # code generation
end</code></pre><p>è¿™é‡Œ mod æ˜¯moduleçš„åå­—ï¼Œnameæ˜¯å‡½æ•°çš„åå­—ï¼Œnargsæ˜¯å‡½æ•°è¾“å…¥å˜é‡çš„ä¸ªæ•°ï¼Œç„¶åæˆ‘ä»¬å°±å¯ä»¥ç”¨å¦‚ä¸‹çš„æ–¹å¼æ¥æ‰¹é‡äº§ç”Ÿè¿™äº›å¯¼æ•°çš„å®šä¹‰</p><pre><code class="language-julia">for (mod, name, nargs) in keys(DiffRules.DEFINED_DIFFRULES)
    f_ex_head = Expr(:., mod, QuoteNode(name))

    if nargs == 1
        df_ex = DiffRules.diffrule(mod, name, :x)

        name === :abs &amp;&amp; continue # exclude abs, it cannot be directly broadcasted

        @eval begin
            $(f_ex_head)(x::AbstractNode) = register($(f_ex_head), x)
            gradient(::typeof($(f_ex_head)), grad, output, x) = (grad * $df_ex, )
            gradient(mt::Trait.Broadcasted{typeof($f_ex_head)}, grad, output, x) = (@.(grad * $(df_ex)), )
        end
    elseif nargs == 2
        df_ex = DiffRules.diffrule(mod, name, :x, :y)

        @eval begin

            $(f_ex_head)(x1::AbstractNode, x2) = register($f_ex_head, x1, x2)
            $(f_ex_head)(x1, x2::AbstractNode) = register($f_ex_head, x1, x2)
            $(f_ex_head)(x1::AbstractNode, x2::AbstractNode) = register($f_ex_head, x1, x2)

            gradient(::typeof($f_ex_head), grad, output, x, y) =
                (grad * $(df_ex[1]), grad * $(df_ex[2]))
            gradient(::Trait.Broadcasted{typeof($f_ex_head)}, grad, output, x, y) =
                (@.(grad * ($(df_ex[1]))), @.(grad * $(df_ex[2])))
        end
    else
        @info &quot;unknown operator $name&quot;
    end
end</code></pre><p>å¯¹å¦‚ä½•ä½¿ç”¨ä»£ç ç”Ÿæˆï¼Œæˆ‘å»ºè®®ä½ é˜…è¯»Juliaçš„æ–‡æ¡£ï¼š<a href="http://docs.juliacn.com/latest/manual/metaprogramming/">å…ƒç¼–ç¨‹ Â· Juliaä¸­æ–‡æ–‡æ¡£</a> ã€‚æˆ‘åœ¨è¿™é‡Œè·³è¿‡äº† <code>abs</code> å‡½æ•°æ˜¯å› ä¸ºæ‰¹é‡å¹¿æ’­çš„å®ä¸èƒ½å¯¹ <code>if else</code> è¿›è¡Œå¹¿æ’­ã€‚æˆ‘ä»¬éœ€è¦å•ç‹¬å»å®šä¹‰ <code>abs</code> çš„å¯¼æ•°ï¼Œä½†æ˜¯å‰©ä¸‹å‡ ä¹æ‰€æœ‰çš„æ•°å­¦å‡½æ•°éƒ½ç”¨Diffrulesç”Ÿæˆäº†ã€‚</p><h2 id="ä»£ç ä¿®é¥°-1"><a class="docs-heading-anchor" href="#ä»£ç ä¿®é¥°-1">ä»£ç ä¿®é¥°</a><a class="docs-heading-anchor-permalink" href="#ä»£ç ä¿®é¥°-1" title="Permalink"></a></h2><p>ä¹‹åæˆ‘åˆèŠ±äº†ä¸€äº›æ—¶é—´å®ç°ä»¿ç…§PyTorchäº†ä¸€ä¸ªè®¡ç®—Jacobbiançš„å‡½æ•°ç”¨æ¥åšå•å…ƒæµ‹è¯•ã€‚ç„¶ååˆ©ç”¨Traitå°†æ•°ç»„ç±»å‹çš„ <code>Variable</code> é‡æ–°æ’å…¥ <code>AbstractArray</code> çš„ç±»å‹æ ‘ä¸­ä»¥å®ç°æ›´å¥½çš„æ‰“å°ä¿¡æ¯ã€‚</p><h2 id="æ€§èƒ½å¯¹æ¯”-1"><a class="docs-heading-anchor" href="#æ€§èƒ½å¯¹æ¯”-1">æ€§èƒ½å¯¹æ¯”</a><a class="docs-heading-anchor-permalink" href="#æ€§èƒ½å¯¹æ¯”-1" title="Permalink"></a></h2><p>å¥½äº†ï¼åˆ°æ­¤æˆ‘ä»¬å°±å†™å®Œäº†è¿™ä¸ªè‡ªåŠ¨å¾®åˆ†åº“äº†ï¼Œå®ƒçš„æ€§èƒ½æ€ä¹ˆæ ·å‘¢ï¼Ÿæˆ‘èµ·åˆä»¥ä¸ºè¿™ä¹ˆç®€å•çš„ä¸€ä¸ªå®ç°åªæ˜¯ä¸€ä¸ªç©å…·ï¼Œä½†å®é™…ä¸Šå®ƒçš„æ€§èƒ½éå¸¸ä¸é”™ï¼ æˆ‘éœ€è¦è®¡ç®—ä¸€ä¸ªç§°ä¸ºMPSçš„ä¸œè¥¿ï¼ˆMatrix product stateï¼‰ï¼Œæ‰€ä»¥æˆ‘åœ¨è¿™é‡Œä½¿ç”¨äº†æˆ‘ä½¿ç”¨æœ€é¢‘ç¹çš„æ“ä½œè¿›è¡Œbenchmarkï¼Œè¿™ä¸ªæ“ä½œæ˜¯ tr(x1 * x2) ï¼Œè¿™é‡Œ x1å’Œx2æ˜¯çŸ©é˜µï¼Œç„¶åå¯¹å…¶æ±‚è¿¹ã€‚</p><p>æ‰€ä»¥æˆ‘é¦–å…ˆä¸ºYAADå®ç°äº†è¿™ä¸¤ä¸ªç®—ç¬¦ï¼š</p><pre><code class="language-julia"># è¿™ä¸€éƒ¨åˆ†å…¶å®å·²ç»åœ¨DiffRulesè¿›è¡Œä»£ç ç”Ÿæˆçš„æ—¶å€™å®šä¹‰è¿‡äº†
Base.:(*)(lhs::Value, rhs) = register(Base.:(*), lhs, rhs)
Base.:(*)(lhs, rhs::Value) = register(Base.:(*), lhs, rhs)
Base.:(*)(lhs::Value, rhs::Value) = register(Base.:(*), lhs, rhs)

# è¿™é‡Œå¼€å§‹æ˜¯æ–°çš„å®šä¹‰
using LinearAlgebra

LinearAlgebra.tr(x::Value) = register(LinearAlgebra.tr, x)
gradient(::typeof(tr), grad, output, x) = (grad * Matrix(I, size(x)), )

function gradient(::typeof(*), grad, output, lhs::AbstractVecOrMat, rhs::AbstractVecOrMat)
    grad * transpose(rhs), transpose(lhs) * grad
end</code></pre><p>julia</p><p>ç„¶åæˆ‘é€‰å–äº†å‡ ä¸ªJuliaçš„åº“ï¼ˆZygoteï¼ŒFluxï¼ŒYAADæ˜¯æˆ‘çš„ï¼‰ï¼Œè¿˜æœ‰PyTorchåœ¨CPUä¸Šè¿›è¡Œäº†ä¸€ä¸‹æ¯”è¾ƒ</p><pre><code class="language-julia">Zygote.@grad LinearAlgebra.tr(x) = LinearAlgebra.tr(x), Î”-&gt; (Î” * Matrix(I, size(x)), )

function bench_tr_mul_yaad(x1, x2)
    z = tr(x1 * x2)
    YAAD.backward(z)
    x1.grad, x2.grad
end

function bench_tr_mul_autograd(x1, x2)
    z = AutoGrad.@diff tr(x1 * x2)
    AutoGrad.grad(z, x1), AutoGrad.grad(z, x2)
end

function bench_tr_mul_zygote(x1, x2)
    Zygote.gradient((x1, x2)-&gt;tr(x1 * x2), x1, x2)
end

function bench_tr_mul_flux(x1, x2)
    z = tr(x1 * x2)
    Flux.Tracker.back!(z, 1)
    x1.grad, x2.grad
end</code></pre><p>ç„¶ååœ¨Pythoné‡Œæµ‹è¯•PyTorchï¼ˆæˆ‘ä»¬çš„æ¥å£å’ŒPyTorchéå¸¸ç›¸ä¼¼ä¸æ˜¯å—ï¼Ÿï¼‰</p><pre><code class="language-python">def bench_tr_mul_torch(x1, x2):
    z = torch.trace(torch.matmul(x1, x2))
    z.backward()
    return x1.grad, x2.grad</code></pre><p>ç„¶åè¾“å…¥å®šä¹‰å¦‚ä¸‹ï¼š</p><pre><code class="language-julia">xv, yv = rand(30, 30), rand(30, 30)
yaad_x, yaad_y = YAAD.Variable(xv), YAAD.Variable(yv)
autograd_x, autograd_y = AutoGrad.Param(xv), AutoGrad.Param(yv)
flux_x, flux_y = Flux.param(xv), Flux.param(yv)</code></pre><p>æ­¤å¤–ï¼Œåœ¨è¿›è¡Œæµ‹è¯•ä¹‹å‰ï¼Œæˆ‘ä»¬å®ç°ä¸€ä¸ªæ‰‹åŠ¨è®¡ç®—æ¢¯åº¦çš„ç‰ˆæœ¬ä½œä¸ºåŸºå‡†ï¼š</p><pre><code class="language-julia">function bench_tr_mul_base(x1, x2)
    z1 = x1 * x2
    z2 = tr(z1)

    grad_z1 = Matrix{eltype(z1)}(I, size(z1))
    grad_z1 * transpose(x2), transpose(x1) * grad_z1
end</code></pre><p>ç„¶ååœ¨Juliaé‡Œæˆ‘ä»¬ç”¨ <code>@benchmark</code> å®æ¥å¤šæ¬¡æµ‹é‡ä»¥è·å–è¿è¡Œæ—¶é—´</p><pre><code class="language-julia">julia&gt; @benchmark bench_tr_mul_autograd(autograd_x, autograd_y)
BenchmarkTools.Trial:
  memory estimate:  33.20 KiB
  allocs estimate:  82
  --------------
  minimum time:     50.218 Î¼s (0.00% GC)
  median time:      62.364 Î¼s (0.00% GC)
  mean time:        90.422 Î¼s (9.86% GC)
  maximum time:     55.386 ms (99.86% GC)
  --------------
  samples:          10000
  evals/sample:     1

julia&gt; @benchmark bench_tr_mul_yaad(yaad_x, yaad_y)
BenchmarkTools.Trial:
  memory estimate:  51.50 KiB
  allocs estimate:  16
  --------------
  minimum time:     10.387 Î¼s (0.00% GC)
  median time:      13.429 Î¼s (0.00% GC)
  mean time:        24.273 Î¼s (45.13% GC)
  maximum time:     55.963 ms (99.96% GC)
  --------------
  samples:          10000
  evals/sample:     1

julia&gt; @benchmark bench_tr_mul_zygote(xv, yv)
BenchmarkTools.Trial:
  memory estimate:  29.98 KiB
  allocs estimate:  10
  --------------
  minimum time:     42.527 Î¼s (0.00% GC)
  median time:      46.640 Î¼s (0.00% GC)
  mean time:        56.996 Î¼s (15.31% GC)
  maximum time:     51.718 ms (99.90% GC)
  --------------
  samples:          10000
  evals/sample:     1

julia&gt; @benchmark bench_tr_mul_base(xv, yv)
BenchmarkTools.Trial:
  memory estimate:  28.78 KiB
  allocs estimate:  5
  --------------
  minimum time:     6.413 Î¼s (0.00% GC)
  median time:      8.201 Î¼s (0.00% GC)
  mean time:        12.215 Î¼s (31.57% GC)
  maximum time:     11.012 ms (99.87% GC)
  --------------
  samples:          10000
  evals/sample:     5

julia&gt; @benchmark bench_tr_mul_flux(flux_x, flux_y)
BenchmarkTools.Trial:
  memory estimate:  30.25 KiB
  allocs estimate:  24
  --------------
  minimum time:     8.009 Î¼s (0.00% GC)
  median time:      10.002 Î¼s (0.00% GC)
  mean time:        14.412 Î¼s (30.14% GC)
  maximum time:     16.286 ms (99.87% GC)
  --------------
  samples:          10000
  evals/sample:     3</code></pre><p>ç„¶åPyTorch (0.4.1) ä¸Š</p><pre><code class="language-python">In [4]: x = torch.rand(30, 30, dtype=torch.float64, requires_grad=True)

In [5]: y = torch.rand(30, 30, dtype=torch.float64, requires_grad=True)

In [6]: %timeit bench_tr_mul_torch(x, y)
76.8 Âµs Â± 1.68 Âµs per loop (mean Â± std. dev. of 7 runs, 10000 loops each)</code></pre><p>æ‰€ä»¥æˆ‘ä»¬èŠ±äº†å°åŠå¤©å®ç°çš„è¿™ä¸ªè‡ªåŠ¨å¾®åˆ†è¿˜ä¸èµ–å˜›ï¼Ÿåªæ¯”åŸºå‡†æ€§èƒ½æ»¡äº†å‡ ä¸ªå¾®ç§’ï¼Œæ„å¤–çš„æ˜¯å®ƒç«Ÿç„¶æ¯”PyTorchå¿«äº†ä¸å°‘ã€‚ç„¶åFluxçš„Trackeræ€§èƒ½ç«Ÿç„¶éå¸¸æ¥è¿‘æ‰‹åŠ¨æ±‚å¯¼ï¼</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../define-your-own-matrix/">Â« å®ç°ä½ è‡ªå·±çš„ç¨€ç–çŸ©é˜µ</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 13 April 2020 18:04">Monday 13 April 2020</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
